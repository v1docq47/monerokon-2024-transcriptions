# Люк 'Kayaba' Паркер

_**Приватные смарт-контракты: способ обеспечения программируемости Monero**_

_В сообществе Monero очень часто обсуждается возможность внедрения смарт-контрактов, однако с ними связано много вопросов, касающихся приватности, эффективности и сложности. Спецификация любой виртуальной машины занимает несколько страниц, а её опкоды обсуждаются годами. Риск отказа в обслуживании является угрозой с точки зрения стабильности Monero, а отсутствие приватности, характерное для большинства виртуальных машин, просто неприемлемо._

_Эта презентация посвящена потенциальному развитию протокола, где смарт-контракты выражены в алгебраических терминах (как часть спецификации) и характеризуются постоянным временем выполнения (при отсутствии риска отказа в обслуживании) с сохранением приватности кода контракта, входящих данных и выполнения без доверительных настроек._

[https://youtu.be/5pGR03Fj5FE](https://youtu.be/5pGR03Fj5FE)

---

_**Люк:**_ Привет всем! Меня зовут Люк Паркер. Также меня знают как kayaba или kayabaNerve. Сегодня я снова повторю всю вводную часть, так что прошу прощения у тех, кто будет слушать её уже в третий раз. Но, это новое выступление, так что… Я являюсь разработчиком доказательств участия на базе полного блокчейна и их версии "плюс-плюс", а также децентрализованной биржи Serai, поддерживающей обмен Monero, Bitcoin и Ethereum. Также я являюсь членом комитета фонда MAGIC Monero, так что, если вы являетесь налогоплательщиком в США и хотите пожертвовать на развитие Monero и получить налоговый вычет - добро пожаловать в MAGIC! Помимо всего этого, это уже моё пятое выступление на MoneroKon, чем я не могу не гордиться.

И я хочу начать с глобального отказа от ответственности. Ведь никто не говорит: "Я обещаю, что это никогда не будет реализовано. Никто не работает над этим. Даже не ждите. А если вам это действительно нужно, подождите хотя бы лет десять. Ну и выделите мне несколько миллионов на исследования и разработку". Это достаточно интересная тема. И я хочу подвести к вас ней, хочу, чтобы всё сказанное учитывалось при обсуждении обновлений в будущем. Так, например, когда-нибудь настанет время постквантовой технологии, и нам придётся переписывать значительные куски протокола. Но это никак не учитывается ни краткосрочной, ни среднесрочной, никакой дорожной картой последующих обновлений.

Итак, смарт-контракты. Для тех, кто не в курсе, это автономно выполняемые программы. Если вам нужно что-то сделать, но вы не хотите полагаться на человека, который медлителен и может не справиться с задачей, вы можете попросить смарт-контракт сделать это за вас, и он просто сделает это. Смарт-контракты обеспечивают работу большинства децентрализованных финансовых систем. Достаточно упомянуть, что сейчас происходит в связи с увлечением криптовалютами, все эти приложения на базе Ethereum, и почти все они используют смарт-контракты. Они позволяют осуществлять децентрализованный обмен без дополнительных доверительных настроек, и так далее, и тому подобное.

В случае с Ethereum они также способствовали построению приватных протоколов, таких как Railgun, который позволяет защитить свои монеты и отправлять их привато так, чтобы никто этого не видел. Несмотря на то, что у "эфира" нет встроенной функции, отвечающей за приватность, благодаря тому, что смарт-контракты становятся полноценными, они уже сами могут реализовывать протоколы обеспечения приватности.

Это также позволяет создавать мосты с минимальным фактором доверия. Это может быть смарт-контракт, оценивающий состояние Bitcoin и ищущий определённые формы заблокированных Bitcoin. После этого, если со стороны Bitcoin также будет использоваться смарт-контракт, он сможет разблокировать Bitcoin при определённых условиях, скажем, в Ethereum или Monero.

И ещё лично мне очень нравится, что они позволяют масштабировать решения второго уровня. То есть различные проекты, использующие различные технологии и стеки, могут определять свои собственные блокчейны, обладающие свойствами завершённости и безопасности базового первого уровня.

Но существует длиннющий список причин, по которым не следует добавлять смарт-контракты в Monero. Если выразить их кратко: смарт-контракты не обладают свойством приватности. Технически они могут быть таковыми, и я говорил об этом, но в целом они не являются приватными - все видят, что происходит. Также, случается, что они работают довольно медленно, и мы переходим от простого действия перевода денег своему другу к выполнению целой программы, проверке, имеет ли она доступ ко всем необходимым базам данных и успешно ли производит запросы. Также смарт-контракты могут занимать много места. По-моему, для создания полного узла Ethereum необходимо около двух терабайт памяти. И ещё одна из главных проблем, связанных с их реализацией в Monero: в этом случае нам пришлось бы принять одну из спецификаций, а на самом деле их несколько, и в каждом случае найдутся свои причины не делать этого. Это банально порождает много хлопот, связанных со спорами, какая из спецификаций правильная, и с какой из них мы можно двигаться дальше, и которую мы будем поддерживать все последующие годы.

И теперь, когда мы разобрались, что такое смарт-контракты и почему их не стоит добавлять в Monero, я перейду ещё к одному кирпичику. На этот раз это будут zk-SNARKs. zk-SNARKs - это доказательства с нулевым разглашением, которые не раскрывают ничего из содержащегося внутри самого доказательства. Они просто доказывают общую взаимосвязь, и проверяются быстрее и меньше, чем программа, которую они выполняют. Тот факт, что они и быстрее, и меньше, наделяет их очень интересными свойствами.

Приведу несколько грубых цифр. Если кто-то действительно разбирается в вопросе и ему они не понравятся, можете придушить меня, но, пожалуйста, дождитесь окончания выступления. Так, проверка программы размером два в тридцать второй степени может потребовать два к шестнадцатой степени усилий. Это если выразить сложность квадратным корнем.

И поскольку мы можем поместить эти большие программы в меньшие доказательства, фактически мы в состоянии произвести рекурсию доказательств zk-SNARKs. Мы можем поместить программу 2\** 32 в доказательство 2\**16, а затем проверить её как программу в доказательстве, что потребует всего 2**8 усилий. Таким образом, мы можем уменьшать его с каждым разом, пока не достигнем минимального порога - наименьшего доказательства, которое может проверить доказательство на один шаг больше. Это и есть порог рекурсии и то, чему, по сути, посвящено это выступление.

Итак, сегодня в Monero используются выходы, связанные с одноразовыми ключами. Мы изменим это. Выход будет связан с одноразовой программой. И уже не ключ будет определять, можно ли потратить какой-то выход, а это будет делать программа. При этом, опять же, не нужно будет проверять, была ли подписана транзакция одноразовым ключом. Вместо этого предоставлялось бы zk-доказательство существования некоторой программы. При этом мы не будем говорить, какая программа выполняется в тот или иной момент. Это будет внутри доказательства с нулевым разглашением, и мы бы просто сказали, что она соответствует. А поскольку программа, связанная с выходом, соответствует, что подтверждается доказательством с нулевым разглашением, это означает, что никто не сможет узнать, что это за программа и какие аргументы ей были переданы, чтобы обеспечить соответствие, - они будут совершенно неотличимы друг от друга. Таким образом, все выходы будут выглядеть одинаково, несмотря на наличие независимой программируемой логики, определяющей, можно ли их тратить.

Это также обеспечивает весьма полезное свойство идентичности времени верификации и размера доказательства. Если бы можно было сказать, что программа выполняется в два раза медленнее, или, что проверка правильности расходования выхода заняла в два раза больше времени, можно было бы увидеть, что программа в два раза больше. Поэтому необходимо, чтобы время верификации и размер доказательства были идентичными. И это также означает, что смарт-контракты не будут медленными даже будучи большими. Неважно, маленькая ли программа или большая - это уже не проблема Monero, а проблема того, кто должен будет её решить. Так что в этом смысле достигается устойчивость к отказу в обслуживании.

Эта идея пока ещё не является полной, и я хочу немного вернуться назад и поговорить об этом. Если взглянуть на модель книги ордеров, используемой какой-либо децентрализованной биржей или любой биржей вообще, в этом случае Элис просто говорит: "У меня есть 5 ABC, и я хочу получить 10 XYZ. Кто хочет со мной поменяется?". И Боб просто отправляет 10 XYZ, получая 5 ABC взамен. Это самый простой пример децентрализованного обмена, осуществляемого с помощью смарт-контракта - как только Боб выполнит свою часть обмена, Элис сможет получить желаемые 10 XYZ. Главное, что следует отметить, - состояние в данном случае полностью моделируется в потребляемой форме. Здесь нет глобального состояния и нет повторно используемых переменных.

Если вместо этого мы обратимся к "автоматизированным маркет-мейкерам" - модный термин, который мне не хотелось бы разъяснять, но, видимо придётся - он был популяризирован такими децентрализованными биржами, как Uniswap, - суть в том, что вместо создания лимитированных ордеров, как бы говорящих: "Я хочу получить это и предлагаю взамен вот это", фактически добавляется ликвидность. Ликвидность обеспечивается постоянно и всегда может использоваться при совершении свопа. Это гораздо быстрее. В контексте смарт-контрактов она обладает всеми этими прекрасными свойствами.

Если углубиться в конкретику, это работает следующим образом: прежде всего, определяется соотношение между текущей суммой ABC и текущей суммой XYZ. И когда Боб захочет совершить своп, ему просто переводится ABC, немного меньше пропорциональной суммы, и это автоматически сдвигает цену по кривой - тут уже просто работает математика. Но, по сути, в данном случае вам не предлагается список доступных на данный момент ордеров, а используется текущий баланс смарт-контракта.

И что по-настоящему здорово в этом случае - всякий раз, когда Боб хочет совершить своп, ему достаточно просто зайти в смарт-контракт, отправить некоторую сумму и получить некоторую сумму взамен. Ему не нужно ничего знать о наличии каких-то конкретных ордеров, и не приходится ожидать появления какого-то конкретного ордера. Если при этом кто-то другой совершает своп с помощью книги ордеров, он использует какой-то из ордеров. Но если этот кто-то другой совершает своп с помощью автоматизированного маркет-мейкера, всё, что при этом происходит - просто сдвигается ценовая точка, и Боб всё равно сможет совершить своп, но уже с другой ценой. Таким образом, это своего рода многоразовое глобальное состояние.

К сожалению, и об этом более подробно говорится на слайде позади меня, потребляемое состояние очень легко смоделировать, хотя оно гораздо более хрупкое и более подвержено возникновению конфликта. А вот многоразовое состояние - это именно то, что необходимо для обеспечения для по-настоящему позитивного опыта пользовательского взаимодействия, и это то, чем характеризуется большинство современных смарт-контрактов. И дело не в том, что вы не можете написать смарт-контракты, использующие только расходуемое состояние, а в том, что современные смарт-контракты, чтобы обеспечить желаемый опыт пользовательского взаимодействия, в значительной степени полагаются на многоразовое состояние, поскольку именно оно позволяет сразу нескольким пользователям одновременно взаимодействовать со смарт-контрактом.

К сожалению, эта идея позволяет использовать только первый тип, только потребляемое состояние. Причина состоит в том, что всё это можно сделать с помощью zk-доказательств. Если бы мы хотели использовать многоразовое состояние, нам бы пришлось определить валидаторы, требующие доверия с точки зрения сохранения приватности. Кроме того, нам бы потребовалось использовать полностью гомоморфное шифрование. А это целое дело. И чтобы избежать нарушения этических принципов Monero, данная идея предусматривает исключительно использование zk-доказательств. Технически она определяет смарт-контракты, но с более ограниченным опытом пользовательского взаимодействия, чем в случае с Ethereum. И это следует признать.

С учётом всего вышесказанного, я бы хотел вкратце рассказать о том, каких гарантий или какие требования с точки зрения приватности пытается удовлетворить эта идея. Сама программа будет приватной. Вы не сможете определить, какая программа находится внутри выхода, точно так же, как сейчас вы не можете определить, какому адресу Monero принадлежит тот или иной выход. Вы не сможете узнать текущее состояние программы. Вы не сможете сказать: "Ага, это тот самый ордер, в котором Элис попыталась обменять 5 ABC на 10 XYZ". Нет, всё будет полностью скрыто. А если к этому присовокупить технологию доказательства участия на базе полного блокчейна, вы бы также не смогли определить, какой именно выход тратится. Технически мы также можем вернуться к использованию кольцевых подписей, и тогда нельзя будет определить, какой выход расходуется в пределах такого подмножества. Но в идеале мы всегда движемся вперёд и никогда не возвращаемся к уже пройдённому.

Но в итоге возникает очевидный вопрос: "Привет, я пользователь. Я хочу использовать смарт-контракт. Как мне узнать, где он находится или что с ним происходит в данный момент?" Если пользователь получит исходный код программы или любого другого смарт-контракта, он всё равно сможет его верифицировать. Это будет эффективный ключ просмотра программы. Тот, кто использует программу, сможет увидеть, что она собой представляет и как работает в данный момент. Но любой внешний наблюдатель или кто-то, не входящий в это сообщество, не будет иметь об этом никакого представления.

Кроме того, сама программа может потребовать, чтобы дополнительные переменные и изменения были зашифрованы так, чтобы любой, обладающий таким ключом просмотра программы, смог расшифровать обновления и проследить их во времени, например, смог узнать, каково состояние децентрализованной биржи на текущий момент, каковы актуальные значения цен, и так далее, и тому подобное.

А это самый забавный слайд, поскольку в соответствии с ним я могу понапридумывать чего угодно и не нести за это никакой ответственности. Я просто хотел рассказать о том, что может произойти в будущем. Мы можем задействовать подписи P-256 ECDSA, заменив ими "причудливые кольцевые подписи" вместе с доказательствами участия на базе полного блокчейна и обобщёнными протоколами Шнорра. Но теперь я также могу заявить, что мы могли бы использовать стандартные, широко распространённые подписи, которые бы просто проверялись внутри программы с нулевым разглашением, и это происходило бы совершенно приватно относительно остальной части блокчейна Monero. Мы могли бы даже получать электронную почту, поскольку электронная почта - это фактически подписанная аутентифицированная инфраструктура. В Ethereum сейчас ведутся работы по использованию zk-доказательств для верификации отправки электронных писем и соответствующего контроля за потоком средств.

Как я уже говорил в начале выступления, меня больше всего интересует реализация решений второго уровня без ущерба для этических принципов Monero. Не добавляя все эти данные, и не раскрывая всё подряд всем и каждому, мы могли бы определить выходы, которые быдли бы всё также совершенно приватными, неразличимыми и смешивающимися с выходами обычных транзакций пользователей. Но несмотря на это, можно было бы проверять полные переходы виртуальных машин Ethereum и создавать новые платформы, использующие смарт-контракты, более масштабируемые приватные протоколы и так далее.

Мы также могли бы создавать клиенты, позволяющие переводить Monero в Ethereum и обратно, и так далее, и так далее, предполагающие наличие доверия исключительно к доказательству работы Monero. И валидатор Ethereum не вызывал бы при этом никаких противоречий, создавая два разных блокчейна на своей стороне.

И есть своего рода обратная сторона, и я должен сказать, хотя и не стоит этого делать, поскольку это действительно интересная идея - несмотря на то, что каждая транзакция занимает одинаковое количество времени и фактор отказа в обслуживании отсутствует, если кто-то создаст очень затратную программу, это всё равно займёт очень много времени. Потому что теперь, вместо того чтобы проверять, является ли передача действительной, приходится проверять, произошло ли выполнение какая-то программы с соблюдением условия нулевого разглашения, а это требует гораздо большей работы.

Практически, при условии обслуживания решений второго уровня блокчейн Monero может разрастись до 2 терабайт. Поэтому нам бы хотелось создать сеть для публикации данных, где мы могли бы в течение ограниченного количества времени хранить необходимые данные. Там была бы куча комментариев. Доступность данных - это тема, определённо заслуживающая обсуждения. Ethereum сделал это со своим хранилищем объектных файлов без доступа к исходному коду. Мне очень нравится это решение.

И потом, даже если бы мы все вместе занялись этим, ну, знаете, все вместе сказали бы: "Да, давайте сделаем это", все в одночасье стали программистами на Rust, уже завтра достали бы свои ноутбуки и начали работать, это заняло бы у нас годы. А потом ещё уйма времени уйдёт на проверку, аудит, доказательство безопасности и обоснование необходимости внедрения в основную сеть Monero. А положа руку на сердце, сейчас большая часть нашего рабочего времени уходит на поддержку узлов, новое программное обеспечение кошелька и окончательную замену wallet2, на который в течение определённого времени поступали жалобы. Кроме того, лично я много работаю над доказательствами участия на базе полного блокчейна.

Так что, даже несмотря на то, что я хотел бы увидеть, как всё это будет реализовано в будущем, как с годами будет становиться всё более реалистичным и желательным, пока это не совсем то, что нужно. И ещё один аргумент против: даже если бы мы уже сегодня продвинулись в этом направлении, и через несколько лет всё было бы готово, вместо этого мы бы предпочли заняться работой над постквантовым обновлением, поскольку оно нам понадобится за несколько лет до того, как появятся квантовые компьютеры, способные атаковать Monero. А это произойдёт в течение следующего десятилетия. Так что до этого момента у нас просто не найдётся времени для многочисленных обновлений протокола, и вследствие этого события нам в любом случае придётся отложить большую часть работы, которую мы сегодня обсуждаем.

Вот вроде бы и всё. Прошу прощения, если я где-то отошёл от темы. Я и сам заметил это. Но если у кого-то есть вопросы, буду рад ответить.
