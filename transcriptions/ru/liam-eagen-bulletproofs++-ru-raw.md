# Лиам Игэн

_**Bulletproofs++**_

[https://youtu.be/e7xX0TQD2tM](https://youtu.be/e7xX0TQD2tM)

---

_**Лиам:**_ Спасибо за терпение. Итак, меня зовут Лиам Игэн. Я буду говорить о Bulletproofs++. Это результат моей совместной работы с Санкетом, Джонасом и Тимом во время моей работы в Blockstream, до неё, и немного после. И да, эта работа была связана с конфиденциальными транзакциями.

Полагаю, тема сама по себе мотивирует, не так ли? Все присутствующие, вероятно, знают всё о блокчейне, децентрализации платежей - мы производим транзакции, которые добавляются в глобальный реестр, где все их могут увидеть. И это как бы фундаментальный принцип в случае с простейшими блокчейн-структурами, такими как блокчейн Bitcoin. И тут возникает проблема, которая заключается в отсутствии приватности. Для того, чтобы проверить, является ли транзакция действительной, и добавить её в реестр, требуется, чтобы её можно было увидеть.

Но как решить эту проблему? В принципе, рецепт прост и имеет множество различных вариантов. Вместо того, чтобы транслировать транзакцию, мы транслируем доказательство знания. А доказательство знания - это, по сути, схема SNARK или доказательство с нулевым разглашением. И при наличии надёжной системы доказательств, в рамках которой доказательства могут быть построены только для действительных транзакций, что бы ни означало в этом случае слово "действительные", мы можем обеспечить приватность данных, связанных с транзакцией. И на данный момент можно найти множество примеров подобных доказательств. Мы заменяем монеты на обязательства, скрывающие их достоинство, из которых нельзя узнать ничего определённого, то есть, при использовании доказательства с нулевым разглашением при проведении транзакции не раскрывается никакой информации о ней, а если точнее, то само доказательство не раскрывает никакой информации.

Существует множество работ, написанных на эту тему, начиная с документов Zerocoin, понятное дело, Monero, Zcash, Tornado Cash, Aztec, множества других проектов. Но все эти работы можно разбить по двум отдельным уровням приватности. Первый - это то, что я называю, думаю, и другие тоже, как правило, называют конфиденциальными транзакциями. Они скрывают внутреннюю информацию транзакции, например, суммы и, возможно, типы активов или скрипты, связанные с транзакцией. Второй уровень приватности - анонимные транзакции или полностью приватные транзакции, которые скрывают не только внутреннюю информацию транзакции, но и информацию между транзакциями. Граф транзакций. Для этого, например, используются кольцевые подписи, что-то вроде обнуления в стиле Zcash, доказательство участия на базе полного блокчейна. Это что касается анонимных транзакций. Термин "конфиденциальные транзакции", по-моему, был введён Грегом Максвеллом. Они стали своего рода предпосылкой для работы над Bulletproofs. А конфиденциальные транзакции включают в себя всё то, что я уже упомянул.

Приватные транзакции сильнее. В каком-то смысле они используют всё то, что делают конфиденциальные транзакции, поскольку если бы мы могли скрыть метаданные транзакции, но не смогли бы сделать то же с внутренними данными, они были бы бесполезны. Но доказать такие транзакции сложнее. Однако за последние 10 лет возможности доказательств с нулевым разглашением значительно расширились. Теперь полностью приватные транзакции можно проводить даже в условиях довольно ограниченных вычислительных ресурсов, с помощью телефонов, например.

Как бы то ни было, всё это было подводкой к тому, чтобы сказать: Bulletproofs++ - протокол конфиденциальных транзакций. Он касается информации, содержащейся в транзакциях. В частности, данными суммы и типа актива. Поэтому возникает естественный вопрос, почему бы не поработать над тем, что обеспечивается анонимными транзакциями. Я сделал это, но эта часть работы в целом применима и к анонимным транзакциям, поскольку, как уже было сказано, они должны скрывать внутренние данные. Итак, в случае с Bulletproofs++ цель состояла в уменьшении размера доказательств. На мой взгляд, наименьший размер доказательства, не требующего доверенных настроек, для верификатора конфиденциальных транзакций, для действительно быстрой верификации, не требующей доверенных настроек, которые, например, как в случае с Groth16, являются одним из условий доказательств с нулевым разглашением - в идеале мы хотели бы избежать этого, поскольку тот, кто устанавливает систему доказательств, потенциально может нарушить их достоверность, а также относительно консервативных криптографических допусков. В частности, речь идёт об эллиптических кривых. Например, использования кривой secp или кривой 25519. И у нас, вроде, это получается.

В самой нашей работе есть много деталей, которые я опущу в рамках презентации. Я сосредоточусь в основном на одной из техник, которая также применима к доказательствам SNARK. Мы взяли Bulletproofs и внесли в них ряд изменений. Bulletproofs обеспечили отсутствие доверенных установок, относительно небольшой размер доказательств и свели всё к дискретному логарифмированию, что, по сути, является тем же самым, для чего используются подписи. Этот механизм не является устойчивым к квантовым атакам, но он достаточно хорошо изучен.

Итак, наша работа содержит четыре теоретических новшества. Первое - новый тип аргументов равенства мультимножеств, о котором я и буду говорить. Мы называем его "взаимным аргументом" и используем для построения доказательств диапазона, позволяющих более эффективно доказать, что значение находится в определённом диапазоне, что, в свою очередь, необходимо, например, для доказательства отсутствия отрицательной суммы. Также нами предлагается общая форма добавления взаимного аргумента в другие схемы. Мы используем вариант аргумента внутреннего произведения Bulletproofs, который немного меньше и на данный момент позволяет уменьшить размер доказательства в целом. Так же мы используем арифметизацию, рецепт добавления взаимного аргумента в другие схемы для построения доказательств диапазона, что немного отличается от того, как работают другие конструкции на базе Bulletproofs, где доказательство диапазона строится как бы в индивидуальном порядке. Так что, всё это, на мой взгляд, очень здорово.

И сейчас я попытаюсь объяснить, что такое взаимный аргумент. Возможно, получится немного теоретически. Как бы то ни было, опустим, у нас есть две последовательности значений, a и b. Будем считать, что это числа или элементы поля. И мы хотим доказать, что они одинаковы вплоть до перестановки. То есть существует некая сигма, и если изменить индексы b, мы получим a. Для этого есть простой протокол Байера и Грота, который мы описали в общем виде. Мы создаём обязательство по этой последовательности, выбираем случайное значение и проверяем эти два произведения на предмет равенства. Вы, наверное, помните, что умножение коммутативно. Поэтому, если последовательности a и b одинаковы, вы можете менять коэффициенты, и обе стороны также будут одинаковыми. Это просто два многочлена с корнями, а корни многочленов - это мультимножества. И это работает именно потому, что умножение коммутативно.

Немного сложно заставить это работать, я имею в виду так называемые аргументы большого произведения. Тем не менее, это работает. Например, в случае с доказательствами PlonKup и PlonK используется более сложная версия этой же идеи. Мы пытаемся каким-то образом отбросить информацию о последовательности a и b, чтобы можно было проверить их равенство. И это своего рода отправная точка для Bulletproofs++. При этом мы хотим использовать сложение вместо умножения. Если просто заменить произведения суммами, это не сработает, поскольку в этом случае вы сможете варьировать числа a и b так, что их будет легко предсказать. Поэтому мы заменяем бета плюс ai, линейные коэффициенты, взятые отсюда, взаимными линейными коэффициентами, а затем складываем их. Это математическая хитрость называется "логарифмической производной". Через несколько месяцев после выхода Bulletproofs++ была опубликована статья Ульриха Хабока, в которой этот способ рассматривается именно в контексте логарифмической производной. И этот метод стал использоваться как стандарт в случае с аргументами поиска во всех доказательствах SNARK, по крайней мере, с аргументами поиска, не имеющими дополнительной структуры.

Круче всего то, что вместо произведений мы получаем суммы и можем поместить множители в числитель. То есть, забежим немного вперёд, так, как показано здесь. Раньше мы умножали линейные коэффициенты, а если перемножить два таких коэффициента, мы получаем квадрат в экспоненте. А работать с коэффициентами в экспоненте неудобно. Работать с ними в числителе гораздо проще. Мы можем умножать. Мы знаем, как делать это эффективно. Поэтому вместо того, чтобы проверять равенство двух последовательностей, мы будем проверять, исчезает или нет одна последовательность значений и умножений.

Таким образом, мы можем представить предыдущую версию как последовательность a с кратностью один, а последовательность b с кратностью минус один. Мы хотим, чтобы они уравновешивались. Но рецепт, по сути, тот же. Мы создаём обязательства по последовательностям а и в и, как и прежде, выбираем случайный запрос. В данном случае мы выбираем взаимные или взаимно линейные коэффициенты. Затем мы проверяем две вещи: сумма взаимных коэффициентов должна быть равна нулю, и все взаимные коэффициенты должны быть построены надлежащим образом.

Я бы назвал это ядром инновационной составляющей Bulletproofs++, и мы используем его в двух целях. Во-первых, мы строим аргумент поиска, позволяющий построить более эффективное доказательство диапазона. Также мы используем его для проведения конфиденциальных транзакций с несколькими активами. Как уже было сказано, конфиденциальные транзакции скрывают внутреннюю информацию. Самый простой вид внутренней информации - это информация суммы. Но, возможно, мы также хотим иметь несколько типов активов в одной транзакции. Это несколько затруднительно. И взаимный аргумент - очень хороший способ сделать это. Он сохраняет все отношения между активами, суммами, количеством активов и так далее в приватном порядке - всё, вплоть до структуры транзакции. И при наличии двух входов и двух выходов у вас не может быть более четырёх активов.

Что такое аргумент поиска? Давайте попробуем построить такой аргумент. Это очень распространённый метод построения доказательств SNARK. Мы хотим показать, что каждый x принадлежит некоторой таблице t. Это просто последовательности значений, которые логически верно записаны для каждого индекса i. То есть, существует некоторый элемент таблицы, которому равен x. Для этого определим кратность mj, где j является индексом таблицы, а i - индексом элементов поиска. Таким образом, mj - это количество раз, которое некоторый элемент x встречается в таблице t, верно? И если мы ищем "один, один, два", и находим в таблице "один, два", то единица будет кратка двум, а два будут кратны одному, потому что мы ищем единицу дважды. Мы просто применяем взаимный аргумент к этой последовательности. Не забываем при этом, что взаимный аргумент определяется для последовательностей кратностей и значений. Итак, мы имеем -1 для всего, что мы ищем, и mj для всего, что есть в таблице. Идея заключается в том, что при добавлении нового x каждый mj увеличивается на единицу, и поэтому они должны уравновешиваться. И если записать всё это алгебраически, то получается следующее: при наличии одного из этих членов для равновесия ему необходимо соответствующее значение в t.

И модульная система подразумевает некоторые технические нюансы, которые не имеют значения в случае с Bulletproofs++, но имеют значение, например, в случае с маленькими полями доказательств SNARK. Это работает очень просто, и это очень легко проверить. Поэтому мы используем это для построения доказательств диапазона с большими основаниями. В частности, мы можем создать 64-битное доказательство диапазона с 16 основаниями, 16 цифрами. Это уменьшает размер доказательства и сложность верификации в четыре раза. Не знаю, упоминал ли я, что размер 64-битного доказательства диапазона при использовании Bulletproofs++ составляет 318 байт, что почти так же мало, как и граф, но не совсем. И это, я думаю, примерно на 40% меньше, чем в случае с Bulletproofs. И это просто базовый вариант построения доказательства диапазона. Берётся x, разбивается на цифры, проверяется, действительна ли каждая из цифр, а затем проверяется соответствие x в сумме этим цифрам.

Теперь немного о конфиденциальных транзакциях с несколькими активами. В данном случае также будет использоваться взаимный аргумент. Список входов и список выходов. Каждый вход - это сумма и тип актива, и каждый выход - тоже сумма и тип актива. И мы хотим, чтобы при проведении транзакции не создавались новые монеты, верно? Мы хотим, чтобы входы точно совпадали с выходами. И, если говорить конкретно, нам также необходимо проверить, имеют ли все выходы положительное значение, чтобы монеты не создавались с помощью отрицательных выходов. Для этого можно использовать доказательство диапазона, о котором говорилось чуть раньше. И если все входы берутся из предыдущих транзакций, возможно, нам уже будет известно, что все они имеют положительное значение, и в этом случае нет необходимости в проверке их диапазона. При этом всё равно нужно проверить сбалансированность всех сумм каждого из активов.

И вновь мы можем использовать взаимный аргумент. На этот раз сумма каждого актива будет кратностью, а тип каждого актива - идентификатором, элементом мультимножества, если угодно. При этом мы просто хотим соблюсти баланс входов и выходов. И снова мы просто суммируем все входы. В числителе мы ставим суммы, а в знаменателе - типы. Представьте, что во входах у нас имеется два Bitcoin и три Bitcoin, а в выходах - один Bitcoin и пять Bitcoin или четыре Bitcoin. При суммировании суммы будут складываться. Так, два плюс три будет пять, и один плюс четыре - тоже пять. Таким образом, эти две стороны сбалансируются, даже если элементы входов и элементы выходов будут разными.

Но теперь представьте, что во входе у нас одно количество Monero, а в выходе - другое. В этом случае знаменатели будут разными. И это необходимо продемонстрировать. Но эти знаменатели гарантируют, что разные активы находятся в разных линейно независимых пространствах, поэтому они не смешиваются. Мы просто проверяем сумму. И это гораздо проще, чем, например, протокол конфиденциальных активов в потоке блоков, который, по-моему, работает схоже с тем, как работает протокол Zcash, где для каждого актива используются обязательства Педерсена и разные групповые элементы. При этом, благодаря системе дискретного логарифмирования они остаются линейно независимыми. Я считаю, что данное решение гораздо проще. Хотя в этом случае суммы должны быть достаточно малы относительно характеристик поля, которые нельзя не учитывать.

Думаю, это лучше иллюстрирует, почему взаимный аргумент представляет для нас интерес. Все используют его для поиска, но мне кажется, что такой вариант его применения несколько недооценён.

И в завершение немного о том, о чём я ещё не говорил. Немного о сокращении размера. Аргумент, как я уже сказал, это вариант Bulletproofs, где вы берете внутреннее произведение вектора с самим собой, и он немного меньше. Это не удивительно, если вы знакомы с Bulletproofs. У нас также есть протокол арифметической схемы, определяющий включение взаимного аргумента в арифметическую схему. Не знаю, есть ли у кого-нибудь из вас опыт работы с Halo2, например, но это похоже на установку рамок поиска. Ну и что касается создания протокола конфиденциальных транзакций с несколькими активами - я описал, как в обоих случаях на высоком уровне можно использовать аргумент поиска и взаимный аргумент и добиться желаемого результата на практике.

На этом у меня все. Спасибо за внимание.
