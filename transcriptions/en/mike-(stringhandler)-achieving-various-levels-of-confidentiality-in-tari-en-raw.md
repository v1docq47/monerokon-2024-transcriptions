# Mike (Stringhandler)

_**Achieving Various Levels of Confidentiality in Tari**_

_Tari allows smart contract developers to choose a level of confidentiality for their use case, ranging from none to strong. In this talk we'll go through each of the levels and what the trade-offs are._

[https://youtu.be/FD2huIa2xyo](https://youtu.be/FD2huIa2xyo)

---

_**Mike:**_ All right, so I'm Mike (Stringhandler) on Twitter and on GitHub if you want to find me there. I'm the lead maintainer on Tari.

So what do we want to achieve today, we want to compare various levels of confidentiality on blockchains and show some examples of Tari contracts. I'm sure none of you have seen them so far. We do have a workshop at 12:40, so just after lunch starts in the Institute of a Cryptoanarchy which is above the entrance, and we'll be going through these in detail, so we'll show you how to actually build your Tari contracts. Just to note that I'm not going to go into any of the SNARK-based technologies. I know we had the talk just now about how we could use SNARKs and stuff. So with SNARKs you'd have to build circuits and it is possible on Tari, but it's not the default flow. So we'll go into it now.

So we're keen to build all of these things. I've seen a lot of talks and how we're gonna build the future. So I wanna help you choose a level of confidentiality that suits your purpose. And how can we build it on Tari?

So starting off, what is Tari? It's a two-layer blockchain. We have a layer one, which is proof of work and it's based on Mimblewimble. Layer two is high throughput. It's sharded by data using Cerberus. Unfortunately, I can't go into the details of that.

But let's go. So why Tari? Why would you choose Tari? So layer one produces safe permissionless money using proof of work. Layer two provides high throughput with fast finality. So as opposed to making the block size bigger, which we saw from ArcticMine thing, you can do that on a layer one, but you don't have that fast finality. So you're still waiting about two minutes for every block to come through. But on Tari layer two you'll have, we're aiming for less than 10 seconds on finality across the network.

So it's sharded by data, not by contracts. So you'll be able to interact with multiple different contracts, DEXs and AAMs and that kind of thing. We're very focused on developer experience. So we've built an object model which makes it very easy to design what you want and to build it. And we've got a very low barrier to creating confidential assets and transactions.

There we go. Ok, so when is Tari? That's the big question, right? So as you've seen on the T-shirts that we have there, layer one is in mainnet 2024, sometime during the year. And we've got a devnet up and running for layer two now, already available. So if you've got a smart contract, you can deploy it to devnet.

All right, so how is Tari? This is obviously a very small slide. I'm sorry about that. This is a "hello world" example. So this is what your Tari contract would look like. It's written in Rust. It gets compiled to WASM and gets executed on a virtual machine, a WASM virtual machine. All the nodes would run the code and agree on the output. And then if they all agree, then we would commit it to the blockchain. Right, so the "hello world" example will go through some more details. But this is what it looks like. And the new methods would be where you would be instantiating the component, and that's where it's going to fit into there.

All right, so before we go into what the different levels are, I just want to take a step back and just look at what is the requirement for money? So if I'm going to be exchanging money with someone, what is the test that we have to do? Right? And these are the two that I always think about is, is it real? So when I receive something, is it real? And has it been spent? And if you've got an idea for building something on the blockchain, I like this being the test of should this be on the blockchain or should this be some kind of other application? And so is it real? And who do you want to prove that it's real to? If you only want to prove that it's real to yourself, then you can just make believe. But whenever two people are interacting with each other, first thing you do is you check if it's real.

So here's an example. So here's a Facebook ad where someone's selling a gaming driving wheel. They're selling a 5,000 South African Rand. So if you want to buy this, these are the things that we would be checking. So is it real? So the seller, when he gets the cash from someone, if he gets the cash in exchange for the real, the first thing he's going to do is look at and see whether the money is actually real or has it been printed off of a printer or forged or something like that. If it's a bank, then we have to trust the bank to say that it was real. From the buyer's side, it's very simple: does he actually have the item? But the second thing is has it already been spent? Now for cash and banking, we already know that, we're so used to this, we don't even do this test, right? If it's cash, we know that it's, we can see that the money is there. If it's a bank, the bank tells us that it has not been spent. For the actual item now, if it's in person, you can see the guy has the steering wheel. But if it's online, there's a very good chance that he has sold this to someone else already. So these are the two things that we're looking for when we're designing some kind of protocol of exchanging money. And that's easy to do.

So this was the breakthrough that Bitcoin had, right? So as we know, so when Satoshi built this, we removed the idea of trusting a central authority and we could do it electronically. So you didn't have to actually physically have the cash on you. So he created this idea that we don't have to now trust a central authority. We can, two parties can see whether something is real, right? And then the UTXO model that he designed prevents the double spend, right, of the outputs that we refer to as unspent outputs. So the downside of this was obviously that the amounts are visible to everybody and the transaction log is, the transaction history is logged for everyone to see.

He actually did take note of it. This is a quote from the white paper. So, "The traditional banking model achieves the level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method". So, he identified the fact that, you know, this is a little bit less private than what the traditional banking model is. So we're going to go through some of these and we're going to come back to that quote a little bit at the end.

So these are the levels that we have starting off with Bitcoin. Going down we'll find Monero at level 3, but I'm going to go through them so we don't need to worry too much about going through that now.

So level 0 is Bitcoin and Ethereum as we know this is not very confidential. First of all, is it real? The test is, does it exist on the chain somewhere? So I'm receiving some funds, some UTXOs, do they exist? And then we'll check to see whether they are spent already. Bitcoin uses UTXOs to solve this problem. And Ethereum uses accounts and nonces. So there's two different approaches. Ethereum uses what's called the "account model", which we'll see now.

So level zero on Tari. I apologize for pulling up docs here, but this is very easy. We've created a number of different resources that you could create. So if you wanted to create a resource which would be a currency or a non-fungible currency, you can choose to either just a fungible, non-fungible or confidential, depending on your use case. This is how we would mint the initial supply of a fungible token. Remember this is level zero. So we'd create a call onto ResourceBuilder, create a fungible token and with published in this way. And we're going to go through this at workshop if you're interested later at lunch.

Okay, so that's completely transparent. Let's go into the next level. And the next level would be just hiding the amounts.

Okay, so first thing, is it real? Has it already been spent? Now this is exactly the same, but we're using what's called a Pederson commitment. This is a little bit more technical, but we basically take the amount as a private key. We take a new private key that will be a mask, and we'll combine them into a public key. Now, because we're hiding the amounts, we've got to make sure that there's no negative amounts, and that we use a range proof. And this is typically where the size of these transactions starts to balloon. And Bulletproofs is what we use in a lot of, in Monero and Tari.

All right, so this is the API for creating a confidential coin. You see it's very similar, but we'll just be calling on ResourceBuild : : confidential. We need to have an output statement instead of just the amount. And here's a little bit more detail which you can see there, that the amount has been replaced by a commitment. We have some encrypted data in there as well for references and also just to allow the sender to know what the amount is or any details they need to decrypt it.

So unfortunately this is the end of the road for the account model. So on Ethereum is entirely based on the account model. Tari has got an account model built in that we've abstracted on top of the UTXO model, because the Tari second layer is built entirely on UTXOs, but we've abstracted an account model. But if you want to go further at this point, you're going to have to start using UTXOs on layer two.

All right, and this is my hot take here. As soon as you start using UTXOs, you need to scan the full blockchain. And in my opinion, the lack of indexes for light wallets is a bigger obstacle for regulation, that is a bigger obstacle to privacy enhancing technologies than regulation. So what I'm meaning by that is MetaMask has 30 million active users, whereas only 18,000 people are running Bitcoin nodes. And if you're trying to build a privacy enhancing cryptocurrency, everybody needs to run a full wallet, right, which means you have to scan the entire chain. And this is a problem. So if you're looking for an area to get more adoption, I think this is a good problem to try and solve.

All right. So then we go and we've, the amounts are hidden, but the transaction graph is still open. We're gonna now look at level two where we're hiding the sender and the receiver. All right, so these are the idea of using one time addresses which was Satoshi suggested. Mimblewimble, Tari layer one is also built like this. It's the same, because we're just looking for inputs and outputs being spent, you just need to find out if the outputs exist on chain and then we're still marking whether they are being spent, so we can just check whether those have been already spent to tell whether the double spend has happened. All of these require some kind of off-chain communication to negotiate, and yeah, so there's not really much we can show on a Tari contract here because it's all really off-chain. You could do this, but you would still need to build on the off-chain communication.

All right, so then we start getting into where Monero sits, and that's with decoy inputs and ring signatures.

All right, so at this point now, we're taking instead of one input being marked as spent and created as the new, creating new outputs, we've got where we choose a bunch of decoy outputs. So Monero has 11 inputs that it uses as a decoy, Lelantus has a much bigger size.

One of the problems is if you have a very small size of decoys that you have to be careful about how you choose them. So this is the reason that you can't have time locks on Monero, this is the reason that you can't have certain smart contracts like Luke was saying. You gotta be careful about if you include any kind of identifiers in the small input set that you can just automatically eliminate those input sets. I believe it's the same reason that you can't spend for 10 blocks as well.

So if you've got a much larger set, obviously you don't eliminate that many, so that's why Lelantus doesn't need to worry too much about all the outputs looking the same.

All right, but now our test now comes into play. How do we decide whether the money is real that we're receiving, right? So in this case, we just need to make sure all of the inputs do exist, right? But we need some kind of one of many proofs. So we've got an input set of many outputs that we can choose from, and we can either use a ring signature or we can use a one of many proof.

So when I first wrote this as a Tari smart contract, I used Jens Groth's one of many proofs, and I built it that way. But then coming to the second criteria was: how do we work out whether it's been spent or not? So the double spend problem. So you cannot mark any of your inputs as spent when you're creating a input anonymity set, because then that would automatically disqualify them. So therefore all of the inputs have to remain unspent. So the way this is solved is by using a unique linking tag. So in Monero it's called the "key image", but when you create a transaction, if that output is spent, it generates this unique tag. And so what we're gonna do, so in Monero they use CLSAG for this. Lelantus has a very clever thing where they reveal the number. So the way that I built it on Tari, and if you want to build something similar, you can also do this. You can use a different ring signature, strategy I use Triptych, and then to save that linking tag we need to save it in a unique location. So I've used Tari's Cerberus substate address just to store it in a unique location.

Ok, so this is what it would look like. I know you were all wondering. Ok, but that's what it looks like. So basically just create a Triptych statement with an input set, and we can verify this. Now this would be compiled from this Rust into WASM and then it would be run on each of the nodes. At some point we may build this into the API, but I just did it as smart contract.

Alright, so then the next level up from this would be using full membership proofs, which removes the whole decoy selection problem. And Monero Seraphis is a good example of that. I don't have an example yet of how to do this on Tari, but if you are interested in doing this, I've got some ideas, so come and chat to me.

Alright, so let's talk about some of the things that are not currently available on blockchains, that are now available on Tari. Let's go back a bit. There we go.

All right, so one of the things you can do is you could create an NFT that allows you to log into like a Twitch stream without revealing which one of your NFTs you own. So that's quite interesting if you, this is one of your use cases you're interested in doing, let me know and I'm happy to talk about it.

And then if we go back to the white paper, and this may be controversial, but go back to this white paper where we had the level of privacy that was between the two parties involved in a trusted third party, we're working on something like this for Tari, and this is built into the API, where when you're issuing a confidential coin, the issuer can choose a view key, right? And in that case, then the issuer and the parties that are transacting can understand the amounts and the transactions that are happening, but they can't, but nobody else can. So the general public is not available to see who you're transacting with or what the amounts are.

So why would we use something like this? One of the biggest use cases is confidential stable coins. So maybe you wanna pay your employees using a stable coin, but you don't want everybody to know what the amounts are. But you don't want to get into the, some of your employees may not want to have, may not have the appetite for dealing with heavy regulation. So a confidential stable coin is now possible. Exchange based coins, maybe some of the traditional banking use cases like credit and interest can now be made available. It's a safer choice for people who are entering into crypto. And maybe this solves the light wallet problem. Could we see a confidential coin that you use MetaMask to interact with. I think there's definitely some cool possibilities here.

All right, and the important thing is that, I'm not gonna prescribe to you what level of confidentiality you wanna use, but as a user or as a contract designer, you can choose it. And that's why we've gone with this different approach, where you can choose what level suits you.

All right, so later today we've got at lunchtime at 12:40, we've got the workshop where we'll go into some of the earlier levels and how you can build your own contract. There's also a getup project, a Tari project called Awesome Tari, which just shows some really cool examples and a starting point for it.

And that is it.
