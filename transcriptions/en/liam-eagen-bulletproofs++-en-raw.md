# Liam Eagen

_**Bulletproofs++**_

_Bulletproofs++ is a new transparent confidential transaction protocol based on the Bulletproofs inner product argument. It features shorter proof sizes and much faster verification complexity. It also supports efficient multi-asset confidential transactions. This is all made possible by a novel "reciprocal argument" (also known as log derivative lookup)._

[https://youtu.be/e7xX0TQD2tM](https://youtu.be/e7xX0TQD2tM)

---

_**Liam:**_ Thanks for your patience. Yeah, I'm Liam Eagan. I'm gonna to talk about Bulletproofs++. Yep, so it was a paper with Sanket and Jonas, and Tim while I was at Blockstream and before, and a little after. But yeah, so confidential transactions.

Yeah, so I guess motivating, right? We're all kinda here, so we probably already know this, about blockchains, decentralizing payments — we broadcast sort of transactions, which are added to a global ledger, everyone can see all of the transactions. And this is kind of fundamental to the simplest blockchain constructions like Bitcoin. And there's a problem. There's no privacy. Everybody has to see all the transactions to check that they're valid and to add them to this global ledger.

So how do we solve this? Basically this simple recipe that there's a lot of different variations of, but instead of broadcasting a transaction, we broadcast a proof of knowledge of a transaction. And proof of knowledge as in like a SNARK or a zero knowledge proof. And if we have a proof system where it's sound and you can only construct proofs for valid transactions for whatever it means to be a valid transaction, then we can keep data associated with the transaction private. And so there's many examples of this that exist now. We replace coins with hiding commitments to their values, so you learn nothing from the coin commitment, and if our proof is zero knowledge, then the transaction reveals no information about, or the proof I should say, reveals no information about the transaction.

There's lots of work on this, sort of starting with the Zerocoin paper, obviously Monero, Zcash, Tornado Cash, Aztec, lots of projects. But this breaks into kind of two discrete levels of privacy. So the first is what I call, I think people generally call confidential transactions. And these hide internal information of the transaction, so like amounts and maybe asset types or scripts associated with the transaction. And then the second level of privacy is what you might call anonymous transactions or fully private transactions that hide not only the information internal to the transaction, but the information between transactions. So the transaction graph. And this is what you'd use ring signatures for, kind of a Zcash style accumulate nullify type thing, full chain membership proofs. That's for anonymous transactions. So confidential transactions, I think, were introduced by Greg Maxwell. It's also sort of the premise of the Bulletproofs paper. And the private transactions include all the things I've mentioned.

Private transactions are more powerful. They sort of include confidential transactions in some sense because if you had a way to hide transaction metadata but not the internal data it wouldn't be useful. But they're more expensive to prove. However, zero-knowledge proofs have increased in power very rapidly over the last 10 years. So now it is feasible to do these fully private transactions even in very weak computing environments like a phone, I think.

So anyway, all that is to say, Bulletproofs++ is a confidential transaction protocol. So it deals with the information internal to transactions. Specifically the amounts and types of assets. So, like, one natural question is why not work on the anonymous transaction part, and I have, but this sort of piece is broadly applicable to anonymous transactions as well, because like I said, they have to hide the internal data. And so, for Bulletproofs++, the goal was small proof sizes. I believe the smallest non-trusted set of proof sizes for confidential transactions efficient verifier, like concretely fast, no trusted setup, and a trusted setup, as you may know, like Groth16, is one kind of category of zero-knowledge proofs, and ideally we would like to avoid that, because whoever sets up the proof system could potentially violate soundness, and relatively conservative cryptographic assumptions. So specifically just elliptic curves. So like secp or curve 255.19. Yeah, so we kind of accomplished this.

And there's like a lot of details in the paper that I'm not gonna talk about in the presentation. I'm gonna focus mainly on one of the techniques that is also applicable to SNARKs generally. But the way we do this is we sort of start with Bulletproofs and we make a bunch of changes. So Bulletproofs gives us no trusted setup, relatively small proofs, and reducible to the discrete log problem, which is the same thing as signatures that people use. It's not quantum resistant, but it's very, you know, well studied.

So there's mainly four kind of theoretical contributions that the paper makes. The first one is this new type of multiset equality arguments, and this is what I'm going to talk about that we call the "reciprocal argument". And we use this to build basically range proofs, which allow us to prove that a value is in a range, which is necessary for proving that you don't have like a negative amount, for example, more efficiently. We also kind of have a general form of adding the reciprocal argument to other circuits. We have a variation of the Bulletproofs inner product argument that's slightly smaller and helps us get the smallest proof sizes currently. And then we use the arithmetization, right, this recipe for adding the reciprocal argument to circuits to build the range proof, which is slightly different from how other Bulletproof-based constructions work where you kind of build a range proof in a bespoke way. So that's kind of nice, I think.

Yeah, so I'm gonna explain the reciprocal argument. This is maybe a little, I don't know, theoretical. I think it's cool. But we have two sequences of values, a and b. Think of these as like numbers or field elements. And we want to prove that they are the same up to permutation. So there exists some sigma, so that if you change the indices of B, you get A. There's a simple protocol for doing this from Bayer and Groth, and we sort of described as like an IOP or just generically, right? We commit to the sequences, pick a random value, and we check that these two products are the same. So you may recall that multiplication is commutative. So if the sequence of A and B are the same, you can change the factors and both sides will be the same. These are just two polynomials with roots and the roots of a polynomial are multiset. Yeah, so this works because multiplication is commutative.

It's a little tricky to make this work, like these kinds of what people call grand product arguments, but they do. So for example, PlonKup with PlonK uses kind of a more complicated version of this same idea. What we're trying to do is somehow forget the sequencing information of A and B so that we can check that they're the same. And so this is the sort of starting point for Bulletproofs++, and what we wanna do is use addition instead of multiplication. And if you just sort of replace the products with sums, it wouldn't work because then you could sort of vary the A's and B's in ways that would be easy to predict. So what we do instead is replace the beta plus ai, these linear factors from here, reciprocal linear factors, and then we add them. This is a mathematical trick called the "logarithmic derivative". And there was a paper that came out a few months after Bulletproofs++ from Ulrich Habock that kind of talks about this specifically in the logarithmic derivative context. And this technique has come to sort of be used as a standard for lookup arguments in all SNARKs, at least look up arguments that don't have some additional structure.

So the cool thing about making these sums instead of products is that we can put the multiplicities in the numerator, right? That is, skip ahead, right here, see. Because previously we're multiplying linear factors, right? If you multiply two things, then you get a square, and that's in the exponent. And working with things in the exponent in circuits is awkward. Working with things in the numerator is much easier, because it's just a thing. We can multiply. We know how to do that very efficiently. So instead of checking that two sequences are equal, we'll check that one sequence of values and multiplicities kind of vanishes.

So you could think about the previous version as sequence A having multiplicity one, and the sequence B having multiplicity negative one. We want them to balance. But the recipe is basically the same. We commit to the A's and the a's, we pick a random challenge like we did before. This case we commit to these reciprocals or the reciprocal linear factors. And then we check two things, that the sum of reciprocals is zero and that all of the reciprocals are well formed.

So this is like the core, I would say innovation Bulletproofs++, and we use it to do kind of two things. First is we build a lookup argument, which allows us to build a more efficient range proof. And then we also use it to make multi-asset confidential transactions. So as I said in confidential transactions we hide internal information. The simplest kind of internal information is just amounts. But maybe we also wanna have multiple types of asset in one transaction. That turns out to be a little tricky. And the reciprocal argument is a really nice way to do that. And it keeps all of the relationships between the assets and the amounts, and how many assets there are, et cetera, private, up to the structure of the transaction. So if you have two inputs and two outputs, you can't possibly have more than, I guess, four assets.

So what is a lookup argument? I say we build a lookup argument. This is a really common technique in making SNARKs. We just want to show that every x lies in some table t. These are just sequences of values, so written logically right for every i. There exists some element of the table that the x equals to the table. So let's define the multiplicity mj, right? Because the j's index over the table and the i's index over the lookup things. So mj is the number of times that some element x occurs in t, right? So like if we had, we're looking up one, one, two, and the table is one, two, the multiplicity of one would be two, multiplicity of two would be one, because we're looking up one twice. And we just apply the reciprocal argument to this sequence. Remember, the reciprocal argument is defined over sequences of multiplicities and values. So we have a multiplicity –1 for everything we're looking up, and mj for everything in the table. And the idea here is that each mj, when we add a new x over here, we increment m by one, and so they should balance. And written out algebraically, this is what we kinda get, so over here, if we have one of these terms, it needs some corresponding t over here to balance.

And modular is some sort of technicalities which don't really matter for Bulletproofs++, but do, for example, for small field SNARKs. This just sort of works, and it's very easy to check. And so we use it to build range proofs with larger bases. So specifically, we can do like a 64-bit range proof the 16 base, 16 digits. And this reduces the size of the witness by a factor of four and that reduces the verification complexity by a factor of four. And I don't know if I said this, but the size concretely of a 64-bit range proof with Bulletproofs++ is 318 bytes, which is almost as small as the graph, but not quite. And it's like, I think like, 40% smaller than a bulletproof. And so yeah, that's just the basic form of making a range proof, right? You take your x, you split it into digits, you check each digit is valid, and then you check that x sums up to your digits.

Now the multi-asset confidential transactions. So we're also gonna use the reciprocal argument here. The list of inputs and the list of outputs. Each input is an amount and a type of an asset. And each output is an amount and a type of an asset. And what we want from a transaction is that you don't create any new money, right? You want all of your inputs to balance exactly with your outputs. And so concretely, you also want to check that your outputs are all positive, that they're not creating money via a negative output. So you could use a range proof, like I was talking about here, to do that. And if all of your inputs are coming from previous transactions, maybe you already know that they're positive, so you don't have to range check them. But we still have to check that all of the amounts of each asset balance properly.

So we can just use the reciprocal argument again. In this time, the amounts of each asset are the multiplicity, and the types of each asset are the kind of like identifier, the elements of the multi-set, if you will. And we just want that the inputs balance with outputs. And written out again, right, we're just summing over all the inputs. We put the amounts in the numerator and the types in the denominator. Over here. And so imagine that in the inputs, maybe you have like two Bitcoin and three Bitcoin, and then in the outputs you have like one Bitcoin and five Bitcoin, or four Bitcoin. And when you sum, the amounts will add. So two plus three is five, and one plus four is five. So these two sides will balance, even though the elements of the inputs and the elements of the outputs are different.

But now imagine you had like, I don't know, one Monero in the input and another Monero in the output. Then the denominators will be different. And so, I mean, you have to show this. But these denominators ensure that different assets live in different linearly independent spaces, so they don't mix. And yeah, so we just check this sum. And this is a lot simpler than. For example, the block stream confidential assets protocol, which I think is kind of how the Zcash assets work, where you have like a Pedersen commitment and a different group element for each asset, and then they're linearly independent because of the discrete log. I think this concretely ends up working out to be simpler. Although in this case, we do have to check that the amounts are small compared to the field characteristics that can't like wrap around.

Yeah, and I think this is kind of a better example, actually, of why the reciprocal argument is interesting. I mean, everybody uses it for lookups, and I feel like this version of it is somewhat underappreciated.

Yeah, so just to close out, what I haven't really talked about, a lot of the details of how we actually make it small, So the norm argument, like I said, it's a variation of Bulletproofs where you take an inner product of a vector with itself, slightly smaller. Not probably super surprising if you're familiar with Bulletproofs. We also have an arithmetic circuit protocol. How we incorporate the reciprocal argument into the arithmetic circuit. So I don't know if anybody has experience with like Halo2 for example, but this is kind of like building a lookup gate. And then how to actually make the multi-asset confidential transaction protocol. So I described sort of how to high level, how you use the lookup argument and the reciprocal argument in both cases to do what we want, but how do you actually go about it.

And that's it. That's all I have. Thanks.
