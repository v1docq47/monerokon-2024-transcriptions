# Jeffro256

_**Filter-Assist Keys and Flexible View-Tags: More Private and Adjustable Light Wallets**_

_New updates to the Jamtis addressing protocol would allow for a tier of light wallets with even greater privacy guarantees and scaling benefits. Before these changes, light wallet servers could tell a client received funds if those funds were sent twice to the same Jamtis address. They could also tell if a client received funds if those funds were sent to a Jamtis address known to the light wallet server. Finally, a light wallet server could identify churning and pocket-change style transactions of the client with high probability. Recent developments to Jamtis fix all those privacy issues, hopefully paving the way for (almost) totally non-deterministic light wallet implementations. In addition to privacy boosts, the addition of "flexible view-tags" provide the ability for the community to react to scaling concerns regarding light wallets, adjusting the balance between privacy and computation demands, without requiring network updates. We discuss the pros/cons of these changes in detail, what is theoretically still left to solve, as well as how these changes could enable real-world use cases._

[https://youtu.be/8E-Ni6Crc8I](https://youtu.be/8E-Ni6Crc8I)

---

_**Jeffro256:**_ Ok, so, why Jamtis in the first place? Just a quick recap.

So, current CryptoNote addresses do not have outgoing view keys, so you cannot see any transaction information going out in a consistent manner. We'll talk more about that later. Some of the just look-ahead tables take up a lot of memory. We've got Janus attacks, too many address types, so we should have another type. And then address generation requires view access or payment IDs. Cake Wallet has probably messed with this. If you want to generate new addresses, except an arbitrary amount of payments, you need your spend keys or you need view access to the payment IDs. And most importantly to me is light wallets privacy kind of sucks. So let's talk about that. Why does it suck?

So as you can see in this fancy little diagram here, whenever you give your view key, to an LWS, a light wallet server, they can see all incoming e-note information, amounts included, even for your change e-notes. So what this means is that combining it with ring info, and Justin Berman did a really good talk about this about a year ago at the previous MoneroKon, view keys, well they're only supposed to see incoming about 95 % of the time actually see all transaction details. So it's pretty terrible for privacy, but you also can't build any actual apps that depend on outgoing amounts. So let's create a new scheme that addresses all these issues.

And then disclaimer: a lot of this work is Ukoe's and tevador's. I just added a little modification to it. So credit where credit is due, they did majority of this Jamtis work.

So how Jamtis already improves light wallet privacy is we have between the sender and the receiver, just like CryptoNote, we have a shared secret. They put a public key on the chain, and there's a public key inside the address. You do a shared secret between those two. And in CryptoNote addresses, that shows all information. That shows everything, like I was talking about. You get to see amounts, you get to know for sure that they've received a e-note to a certain address. So Jamtis already hide some of that information. So you get to see a view tag and what's called a new thing called an "address tag", I'll talk about that later, and then the other transaction information is hidden. But that address tag will become a problem.

So. And then what we can do is we can give what's called the "find-received key" is the old name for it. And you can give that to the light wallet server. What they can do is they can calculate the view tag and the address tag for all the e-notes. They don't get the amounts. They don't get to say for sure that you own something. So that's the key that you would give to your light wallet server. So that view tag is about one byte worth of information. And that means that there's 256 different values for it. They can prune down your scanning volume by about 99.6%.

_**Audience:**_ About...

_**Jeffro256:**_ Yeah, about. There's some rough details there. Let's say one in 256. So that's basically what I saying. One byte can hold 256 values. So if it matches, the chances that someone unrelated to you matching that is about one to 256. So that allows you to massively reduce the amount of scanning you have to do.

So what are some downsides to this approach? So the address tags actually are just 128-bit chunks of information encoded in the public address. So this is actually public information some of the time to receivers. But you generate them randomly, and since it's 128 bits, the chance that while the light wallet server is scanning, that two address tags show up, then that's like an overwhelming probability that it is the same person, and you probably know that they own that e-note. You don't know what amount it is, but they probably own those two. And in a similar way, if you already know the address and you see the address tag while you're scanning, then you know for sure they own that e-note, which is not ideal.

And then further, you cannot give someone a secret that lets you generate addresses on your behalf, because if you do, they can use the address tags to find out all the times that you've received, even though they don't know the amounts, they know for sure you are involved receiving those transactions.

And then there's also the problem of if you have too many view tags within the same transaction, you can accumulate exponentially the probability that all these view tags match, because that normally should never happen. So for example, what I have here is if you have 16 view tags that match, that's 8 bits times 16, 128 bits, that should basically never happen ever for any reason. The probability that would just randomly happen if you're unrelated to that transaction is about the same chance as you guessing someone's AES key randomly on the first try. So if that happens you can probably say: "Yeah this guy's involved with this transaction".

And then finally, one issue we want to talk about is, how did we decide the 256 value? How do we decide 99.6 % scaling? Why is that a good value? Is it a good value? So whenever you have a fixed size, one byte, you're basically stuck with that. Whether we know if that's going to be good or not in the future is unknown. We might want it to be smaller. Maybe we only want to cut down the anonymity size 50 times. And we only care about cutting it down 50. What if we want 2,000 transactions per second and we want to cut it down way more in the future. We don't really have a way to change that as is.

So let's start talking about how we can fix some of these. So going back to that original example, this is how the new version would work. As you can see there's two shared secrets now. Before there was one shared secret, now there's two. The first one only unlocks the primary view tag. And then there's a secondary view tag. The second key unlocks all the other transaction information in that secondary view tag.

So what you would do is you would give the first key, the filter-assist key, to the light wallet server and keep the other key private to yourself. So now that they don't have that key, there is no way for them to derive any of this other transaction information.

So this does require an increase to the size in the addresses. So we go from, so this is the crypto node address on the bottom. This is what it would have been with the older Jamtis scheme, new Jamtis scheme quite a bit bigger. It still fits in a tweet. I'm not gonna call it an X.

So, and then a good question would be, now that we're doing two shared secret exchanges, is this going to be twice as slow? That's a good question, but no. So the first, because we checked view tags in between the two shared secrets, we actually only checked the second one about one in 256 times, assuming a one byte view tag. So that ends up only making it about 0.4 % slower. Let me clarify, that's for full wallet scanning. So if you never use light wallet server, this feature will only set you back 0.4 % in scanning time.

Let's just skip this part. In the old address tags, there's a little thing called a hint, and we wanna replace that and add a new view tag in that makes sure that we, view tag lets us skip a lot of operations and optimize things. Because the light wallet server, because we're not, it doesn't know the view tags anymore, it cannot check that for us, and we have to do a ECDH exchange instead of a cypher operation, which on the client side is about 100 times slower. But since the bandwidth was already about 100 times lower, so it'd be 65,000 times faster with old Jamtis, it's about 100 times slower than that. Still about 100 times faster than a normal wallet, but that's a trade-off to keep in mind.

So yeah, you might be asking the question, why are there two view tags now?

_**Audience:**_ Is this for email?

Jeffro256:**_ Yeah. We want a view tag for after the second secret exchange to replace the address tag for performance. But now what we can do is we can actually mix these two. We can take a mixture of the first one and the second one. And this gives us some bit of flexibility. Where's the term flexible comes in? We can have a sort of degree of fuzziness, how we want to mix and match these two. So if we had a high number of npbits, that means the primary view tag is going to be very large. And that means that we get to crunch down on the scanning quite a bit. Yeah, just having some value that lets us have a knob that changes this mixing, lets us give us little bit of flexibility. So this is just what I saying. So high npbits value. Lots of crunching down and scanning, but worse for anonymity, but now you can make the trade off, whereas before you were not able to.

And then tackling the view tag privacy issues. So going back to this issue where you've got too many that match, the simple solution is just don't have them match. And then what this means for the light wallet side is that they're gonna have to send all of the e-notes in a transaction if one of them matches. So that does increase bandwidth. This is a change we can go with, maybe, maybe not. Whether we want to is kind of up in the air, but this wouldn't make it so that pocket change or churning is still very private. Yeah, so even if you don't match all the e-notes in this transaction, you still have to send all of them on the light wallet side.

Okay, so let's recap. That was a lot of information. It's a nice succinct table of the features we can expect with the new Jamtis. So current light wallets do not hide any e-note information. They do not hide churns and pocket change. And they don't have any kind of adjustable mechanism for adjusting this. And they cannot generate addresses on the user's behalf without a huge, huge, huge drop in privacy.

And yeah, so the one thing I want to discuss here is that we don't have near instant sync anymore. It's still gonna be about 100 times faster than a full wallet. It's not gonna be near instant because we do have to send about 0.4 % of on-chain data.

Okay, so, enabled use cases. So one thing that can happen now whenever you let people generate addresses on your behalf, one thing you could do with that is, for example, you could make a Venmo. And you can have the service generate addresses for you on your behalf. So if I want to connect to Luke, for example, and pay him some money, I don't have to interact with him. I don't have to like tweet with him. It's just kind of a nice, easy little generate an address for me. And it does that for each individual person, completely non-interactive. And that can be… there's proof so that can be non-interactively verified.

And then peer-ran LWS. It's a lot easier sell to have someone run an LWS on your behalf if you're not also like: "I can see all of your transaction data". So now you don't see all their transaction data, but you still get to give them the gift of fast syncing, which is my friends bug me about that a lot of the time.

Then so cold-hot wallet setups, if you want to be really paranoid, this will make those setups even more private than they are now. So normally how it works is you have a view key, scans it on the hot side, and you move that information over to the cold side, and then you move the key image data back over to the hot side. Now you can completely keep the cold side, the spend cold, completely cold, and you can have it scan, do the second part of the scanning on a device that's like semi-cold. And if you really like AirGap solutions, this helps you with that.

And then more secure self-ran LWS. Some people like to run their own light wallet server, like there's an open source version of OpenMonero, or MyMonero, called Open Monero. You can run that yourself. But if that one were to get hacked, you would be giving basically your entire balance over and all of your transaction history with some exceptions. Now you would not be giving that. You'd only be giving away 4 % of the blockchain data in total, and they can't deterministically gain any information from that. Let's see. Yeah, and then private pocket changes and light wallets, which is not possible before.

So what's left? So there are still a few attacks on this. It's not completely free besides the speed. It's also not completely private. Excuse me… Okay, that was I was missing. All right.

So light wallets can, the servers can still probabilistically correlate users based on their number of view tag matches and share transactions. So if you, if we have a network and the server has a whole bunch of people's keys all in one place and I send a whole bunch of transactions to my friend over and over and over again, they can see that we have a statistically unlikely number of transactions that both have view tags inside of them. So they can use that to probabilistically make a social graph of source. So that's one attack. And the other one is, let's say, let's say someone used the early example of this. Let's say you were buying unpasteurized milk from someone, say 20 times, and then they get busted because it's unpasteurized. So someone has their transaction set. You're going to have primary view tags that match inside of that transaction set a statistically higher number of times. And the more times you interact with them, that probability gets exponentially higher. They still can't see anything deterministic, but they can say with a higher likelihood that you might be involved with these transactions if your counterparty and your light wallet server get compromised.

And yeah, that's about all I have.
