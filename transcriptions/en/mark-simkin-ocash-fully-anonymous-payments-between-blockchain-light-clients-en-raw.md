# Mark Simkin

_**OCash: Fully Anonymous Payments between Blockchain Light Clients**_

_We study blockchain-based provably anonymous payment systems between light clients. Such clients interact with the blockchain through full nodes, who can see what the light clients read and write. The goal of our work is to enable light clients to perform anonymous payments, while maintaining privacy even against the full nodes through which they interact with the blockchain._

_We formalize the problem in the universal composability model and present a provably secure solution to it. In comparison to existing works, we are the first ones that simultaneously provide strong anonymity guarantees, provable security, and anonymity with respect to the full nodes. Along the way, we make several contributions that may be of independent interest._

_We define and construct efficient compressible randomness beacons, which produce unpredictable values in regular intervals and allow for storing all published values in a short digest. We define and construct anonymous-coin friendly encryption schemes and we show how they can be used within anonymous payment systems. We define and construct strongly oblivious read-once map, which can be seen as a special data structure that needs to satisfy a stronger notion of obliviousness than what is usually considered. We present a new approach, which is compatible with light clients, for mitigating double- spending attacks in anonymous cryptocurrencies._

[https://youtu.be/Vg8n5DAzbGg](https://youtu.be/Vg8n5DAzbGg)

---

_**Mark:**_ Welcome to this talk, this is OCash, another uncreative name. So this is. I'm Mark, and this is a joint work… I work at the Ethereum Foundation as a researcher in the cryptography team. And this is a joint work with two researchers from the Aarhus University in Denmark, Adam Bletchley Hansen and Jesper Booth Nielsen.

And as a disclaimer, so this is going to tackle a very complicated problem and going to provide a somewhat non-trivial solution or partial solution. Like if you think there are details missing in this talk, then that's because the talk is only 20 minutes long.

Okay, short recall - what is a blockchain? So again, on a very, very high level, so I have this blockchain, which is like a huge amount of data, and I have a client and the client can post and receive money on this blockchain. And because a lot of people do this, then that's really a lot of data. Keeping track of the full ledger really requires you to keep track of hundreds of gigabytes of data. And if you're, let's say, an average user and you don't necessarily want to be a full node, but you still want to use the features that the blockchain provides to you, then maybe you don't want to keep track of hundreds of gigabytes of data for that.

So there are solutions for this. So these are light clients. So there are various designs for it, but like the general gist of it is that rather than storing all of the data that I would need to keep track of everything in the blockchain, I will instead talk to a full node. The full node will provide me with the stuff that I need, and then I communicate with the blockchain through this full node.

So these designs somewhat inherently have what will be the problem that we'll get to is that the client, what the client does, the full node will see, because it acts through the full node. like the client lose, if it wants some privacy, naively loses it towards the full node.

So a separate thing that you might want is anonymous payments - that's MoneroKon. By default in classical blockchains or cryptocurrencies you post transactions, everybody sees everything that is happening. You might not want to have that. You want to have some kind of transaction privacy. So on a very high level, you want to say: "Okay, when I pay someone, you should, by observing the blockchain, by observing what I do, you shouldn't be able to tell who I paid". And there are different solutions to this. There's Zcash, there's Monero, there's others. And they all provide very much different anonymity guarantees.

So we have these two desires or design goals. We would like to have support for light clients. We want to have anonymous payments. Ideally, we would actually to have both. So this is the question that this talk deals with.

And again, on a very high level, really the challenge is that when we say "We want to have anonymity", we don't just mean anonymity against some outside adversary, but we want to have anonymity even towards the full node through which we interact with the blockchain. Okay, so we want to have anonymity in a complete sense.

And one can ask naturally: "I can look at existing approaches that provide me with anonymous payment systems and I can ask, can I make light clients for them?" And again, on a very high level, the problem is that if you look at, for example, Zcash, and they do something called, one can call an accumulator-based approach, then if you want to spend a coin, so transactions are basically coins there, and if you want to spend such a coin, then you need to compute a sort of a proof, but computing this proof requires you to compute it over the full state, more or less. So this means that if you're a light client, you don't really want to do this, but somebody has to do it, so you could ask a full node to do it for you, but then you run into this problem that the full node knows what you want to see. And if you want to get around this, you could use things like private information retrieval, this would incur a humongous amount of work on the full node, so this is not really a practical solution to this problem.

So then there is a ring signature-based approach, like Monero. And while Monero certainly provides a non-trivial amount of privacy, there has been a bunch of recent works and they studied from a graph perspective the anonymity that Monero provides. And it's not necessarily clear how much anonymity you get. So clearly you get some anonymity, but how much is very much an open question. So it's currently not too well understood, I would say is fair to say.

So what is the goal of this work or what was the goal of this work? It was to take a step back and ask: I have these two design goals - I would like to have light clients, anonymous payments. Can I build a cryptocurrency or schematically build one that supports those things nicely, really provide support for light clients, but also provides the strongest anonymity you could hope for?

Okay, so this is what OCash does. This is not a practically implemented thing. This is a very long paper with a bunch of different things. So in this talk, I'm gonna explain what it does, but apart from explaining OCash, I also wanna highlight a few of the objects that we constructed along the way, because maybe you don't agree with the full design, but the objects itself may still be interesting to you.

So as I said, this OCash basically will give you full anonymity in the sense that when I perform a payment, you have no idea who I paid. And when the person collects the payment, nobody can tell which payment was collected. Not even the person who did the payment can see that. And it supports light clients. And looking ahead, one thing that might be controversial to some people is that it will rely on a committee-based approach. So this means that it works for blockchains where consensus is driven forward by selecting committees that perform actions. So if you're opposed to this type of consensus, then that's not for you.

Okay, so there are several things, tools that we construct along the way and I not gonna go into the details, but I think on a very high level maybe you can guess why they could be useful.

So one thing is that throughout the lifetime of this blockchain, there will need to be a randomness beacon. And this randomness beacon will output random values, and they will help you do things. Now, if you're a light client, when you want to do something, you want to interact with the blockchain as little as possible. So you might even not want to read all the randomness beacon outputs. Maybe it outputs a lot of them, you don't want to read them. So what we show is that you can construct a beacon that outputs small values and whenever the next value is about to appear, it's gonna be looking random to you - it's like unpredictable, it satisfies the idea of what a randomness beacon should be, but it also has the nice feature that if you have the last beacon value, you can recompute all the previous random outputs that have appeared so far. So now if you want to store all of the values, you just store a short digest instead of storing the full list of values. So a light client, for example, if it might need a previous value, it will just read the last value and from there compute backwards the one that it needed. So this is one thing.

One thing that we also think is nice is that another problem that you might run into when you try to combine light clients and anonymous payments is that you would like to prevent double spending. So I'm a light client, I receive a payment. I would now somehow would like to be able to check that this is not a double spending attempt. And what we show is that you can do this in a fashion which more or less doesn't require the receiver of the payment to look at the blockchain at all. It just needs to keep track of the payments that it received from that specific payer.

And lastly, we suggest, let's call it an anonymous coin-friendly encryption. As coins get into, on this ledger, I'll explain how it works on a high level in a moment, these will be encrypted values, and then as the blockchain grows, they will move around, they will be re-randomized, and then you will prove stuff about them, like: this is well-formed, this contains that value when I collect a payment and so on and so forth. And if you try to do this naively, then usually to prove that something is, like an encryption is well formed, you will prove this is a well-formed encryption under this public key. But if you want to make an anonymous payment, then ideally you don't want to reveal under what public key something is encrypted. You just want to say: "This is a well-formed ciphertext". So we suggest how you can get all of the things that we think you need, where you basically prove this is a well-formed ciphertext under some public key, which I'm not telling you. And then when somebody decrypts it, you can say: "Well, this ciphertext, I'm not telling you under what public key it was encrypted or what decryption key I use, but this is the message that's in there". So you detach the public key identification possibility from the ciphertext statements that you want to prove.

Okay. So I'm going to provide a very high level overview, basically skipping over 99% of the details. But here we go. So blockchain is back. So the way the system works on a high level is it will work by Alice will not perform a transaction directly to pay Bob. But instead, Alice will pay a dollar to be allowed to put a coin on the blockchain. And then later, Bob will be able to somehow go to the blockchain and say: "Hey, that's my coin", and will collect it. And now if we want to have anonymity, then we basically mean that we would like to hide the recipient of the coin when Alice puts the coin on the blockchain. And when Bob collects it, we would hide what coin Bob collected. So even Alice should not be able to tell that that coin that she put on the blockchain was collected.

So what is the coin in the system? So the coin will be a ciphertext which is encrypted under the recipient's public key. So Alice encrypts something under Bob's public key and that will be the coin. And what it encrypts is something that is a transaction ID. But this transaction ID will be somewhat special, because if you look at it from the outside and you are neither Alice nor Bob, it will just look like a random bit string to you. But if you're Alice and Bob, then you will actually know that this is a highly structured string that contains information.

So, for those who are a little bit familiar with cryptography, the transaction ID will basically be a commitment to a bunch of values and this will later on help Alice to prove that the coin is well formed in some sense, because the committed values in there are well formed. And when Bob collects the coin, Bob will be able to prove that he's allowed to collect the coin, that it wasn't collected before, again because it has some secret structure that they know.

And, oh… we went too far. Yeah, so and I will not explain too much detail, but basically this transaction ID is the thing that will allow Bob to detect double spending. So there will be something in the transaction ID where Bob can look at and be like: "Hey, I didn't see that yet. So this must be the first time this coin is being used to pay me specifically".

Okay, so the other thing, and this is where we get into the territory of things that might be less known to this audience, is oblivious RAM. So, what is oblivious RAM? So forget about blockchains for a second and just think you have Alice and you have an array, like a memory array. And now Alice can perform operations on the array cell. So Alice can say: "Read the entry four". And then she receives back the value. Then she can say: "Hey, write some value into entry seven". And then that happens.

Now you could consider a setting where there's an adversary that observed this old procedure. So it sees what is Alice doing on this memory array and you could say: "Well, I want to hide this information". So one thing that you can do is you can say: "Okay, I encrypt the array". So now Alice will have a decryption key and now she will receive and send encrypted entries. So this is just an encrypted array.

But if the adversary looks at the access pattern, what things is Alice touching, then this is actually not good enough, because just the access pattern itself can leak information about what Alice is doing. You can think of it as like Alice continuously reading the first entry is clearly distinguishable from Alice reading different entries. So just encrypting values doesn't hide all the information you might want to hide.

But there is something that does that. So that hides even the information that the access pattern leaks and that's called ORAM which is short for oblivious RAM. And you can think of it as a data structure that represents an array, but now when the adversary looks at the read and write requests on the data structure, it cannot tell which cells Alice is reading or writing to, it has no clue. And just to give you an intuition of how you could do this, you can think of a very inefficient way of doing it by just linear scanning the array every time you perform an operation. Okay, so you want to read the first entry, you will just scan the whole array and that's it. The adversary will see you scan the whole array. So it clearly doesn't know what you did, but you did receive the one entry that you wanted to look at.

The problem with the solution is that you don't want to read the whole array if you just want to access one array cell. That's highly inefficient. So ORAM basically tells you: "You can kind of have both". It can be efficient and provide this level of privacy.

And the way it works is basically by performing a few little shuffles every time you touch elements. So if I want to read position four in my array, then this will be mapped to some position seven in my ORAM data structure. I will read that. I will also read some dummy values. And then I will mingle them a little bit and write them back. But I will still mostly not only touch a very small part of the overall data structure. And it turns out that this little bit of shuffling around the elements completely hides all the information. And in particular, if you have an array of length n, then to get the security guarantee, you don't need to read just one array cell, but you still need to read exponentially less array cells than doing a full linear scan. So you need to read a little bit, but not too much, hopefully. So polylog is logarithm to some constant, okay?

Okay, so what is the high level idea of this design that we propose? It's more or less as follows. So again, Alice would like to put a coin. Bob would like to get out the coin. Now, our blockchain will not just be a ledger where we append transactions, but instead it will be this ORAM data structure. And what will happen now is when Alice wants to pay Bob, it will place an encrypted transaction ID, which is this format that we have, it will place it into this ORAM data structure. And when Bob wants to collect the payment, it will just tell which location in the ORAM data structures it reads. Here it's maybe helpful to compare it to, let's say, Zcash designs. Okay, if you take a toy accumulator based design, you need to compute the accumulator over all the existing entries, because if you don't look at an entry, you know that's not the coin that is being collected, roughly speaking. But because now ORAM always shuffles elements around a little bit, Bob doesn't need to hide the entries that it looks at. It just says: "I look at this entry and five more, and I prove to you that one of those ciphertexts contains my coin". And even though this is a very small fraction of the overall data on the blockchain, by the guarantees of the oblivious RAM data structure, you still have no clue what was accessed by Bob. You get anonymity among all the coins in the system.

Okay, so this is a wild oversimplification of a lot of things. I just want to kind of outline the challenges that this approach encounters. So the first one is that this array thing that I described is not exactly what we need because we don't really need just a memory array where I put my transactions. It's more like I put coins, later I receive coins. It's a little bit different from an array, but if you know the tricks from this ORAM literature, you can kind of massage them to give you what you want.

The other thing is this ORAM, I said is like, you know, it does a little bit of shuffling operations. So upon every operation, a little bit of it needs to be moved around. And this is where this committee based approach comes into. So if you have a blockchain where consensus is driven forward by a committee, then this committee can take care of this task. And this task is again only touching a very small amount of the overall memory that it has to deal with per operation.

And then the other thing is, you know, I have this array, I keep shuffling around elements, but then later on you're supposed to be like: "Hey, in one of those five cells, there's my coin". So one question is like, how do you know where to look for your coin? And this is kind of like where this randomness beacon will come into play. So when Alice performs the payment, the randomness beacon will publish a value. Alice will be like: "Aha, I know where my coin went". And then it will tell this value to Bob. Much later on, Bob or even Alice will say: "I paid you at this time". Later Bob can use the randomness beacon to recompute that value. This value will somehow magically reveal where in the shuffled memory to look and it will look up the coin there.

This is a wild oversimplification of all of the parts, but I welcome you to read the paper which is online and as you go in the back, it becomes very technical, but the first 10 pages should give you a very, very high level overview of how everything works.

Thank you for your time, and this is the link to the paper.
