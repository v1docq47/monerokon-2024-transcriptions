# Aaron Feickert

_**Aura: Using Privacy-Respecting Technology to Build Secure Voting**_

_Electronic voting is hard. Really hard! Existing approaches to this problem make many tradeoffs, like leaking voter information or trusting voting authorities not to cheat. What we want is a way to conduct a vote electronically that respects voter privacy, allows anyone to verify the results are correct, and minimizes trust in voting and tallying authorities._

_This talk will introduce Aura, a voting protocol that meets these goals. Aura uses several privacy-respecting techniques (including some from private transaction protocols!) to do this. We'll provide a high-level overview of how it works and why it's useful._

_This talk should be accessible to everyone, and no particular technical background is assumed._

[https://youtu.be/A232BJEJp3w](https://youtu.be/A232BJEJp3w)

---

_**Aaron:**_ So I'm Aaron. I spoke earlier in the weekend about security and security models and a little bit briefly on how we discuss how to prove protocols secure. And now I'm going to talk to you about a specific protocol. This is called Aura, and this is about using privacy-respecting technology to build secure electronic voting.

So this is actually joint work with Aram Jivanyan of Firo, Yerevan State University. I work as head of research at Cypher Stack, an applied cryptography R&D consultancy, and the research for Aura was conducted for Firo project. Of course, this is for information only. If you go and use this protocol to conduct an election and it doesn't go well, you don't get to come talking about it.

So, first of all, voting is really hard. It's so hard that I put a little icon there to show you how hard it is. It's very difficult because different types of elections have very different requirements, both in terms of trust, operation, and what you want to get out of it. For example, if you're just having a vote among a committee of people who know each other, and you want it to be by secret ballot, you can probably do that pretty easily. It happens all the time. Then again, if you want to have a secret ballot for a town council, for example, that's going to be more difficult with different trust requirements and different operational principles. That's very different in turn than if you want to elect the president or prime minister of a country which in turn is different than if you want to conduct some kind of electronic, you know, chain-based voting.

And digital voting is even harder. It is maybe twice as hard, so it gets two of those little skull and crossbones icons. Digital voting introduces problems because you've moved from the physical world where - in some sense, we haven't fully solved physical voting, I would say, either, but in some sense, there's certain aspects of it that are well understood for how to manage, for example, physical identities and secure voting practices and counts and tallies. And again, not necessarily fully solved, but at least fairly well understood. But in digital voting, that kind of changes everything. In a lot of places, you don't necessarily have a single well understood digital identity. And you have all sorts of questions on trust and how you might do things like conducting a ballot-based election, how to make it secret, how to tally votes, how to verify that everything was done correctly.

Well, let's look at what a digital voting system might provide. What are some goals that we might want? So for this example, we'll consider kind of four big ones.

The first one is what we'll call ballot privacy. And that means that if you look at a ballot, say on a digital ledger of some kind, a blockchain is a good example of how to do that, nobody should be able to take that ballot and see which candidates are options that ballots selected. That gives away a lot of information and as voting occurs, could influence results.

Second is something we'll call voter privacy. It's different than ballot privacy. Ballot privacy says the selections on the ballot shouldn't be visible to everybody. Voter privacy says you shouldn't be able to take a look at a ballot that's posted onto a ledger and see which voter cast it. It's the idea of kind of a secret ballot. You shouldn't be able to tell who cast the ballot.

The third is verifiability. It should be the case that as all this information is posted onto some ledger, all of the counting and tallying practices are conducted however they might be done. At the end of the day, everyone, maybe whether or not they participated in the election, should be able to cryptographically, which is why we're introducing this at a conference about cryptography, should be able to prove that the results are valid, that everyone who was supposed to vote in the election had the ability to vote in the election, and that all of the counted results match those secret ballots.

And finally, we want trust minimization. And this is kind of the big one. If the officials, either the talliers or the organizers in the election, were to turn evil, or maybe they were always evil to begin with, who knows? They shouldn't be able to cause much damage. We'll probably be able to cause some, we want to kind of minimize the so-called blast radius for what they're able to do. So we don't necessarily want to have to put too much trust in those officials to act honestly.

So as I said, this is a great case for digital ledgers. So distributed public ledgers like blockchains tend to be a pretty good medium for this. So they're often very resistant to tampering, thanks to the benefits of cryptography and network effects, and they can often offer very high public availability. So that's why they're often used for digital asset protocols.

So the general idea for this is going to be that the voter constructs their digital ballot, so either maybe they do it at a polling place or they do it at home, depending on the requirements of the election, and they submit that up to the network. And if it's valid, well, this will have to be checked, the ballot is then added to this public ledger. And at the very end of the election, ballots are somehow, magically for now, tallied. But how can this meet all of the goals, these four goals? Well, here's one example.

So one way to do it is to take some of the techniques that we already use for privacy respecting digital asset protocols and kind of move them over into the ballots and election and voting space. So a lot of the same cryptographic primitives and constructions, which I'm not going to go into a ton of detail on here, can be more or less transferred over. So let's look at kind of some different aspects of private transaction protocols and see how they might correspond to voting protocols.

So in a digital asset protocol, typically what is signed is a transaction, which shows that it is authorized. Well, we're gonna kinda have the same thing, where ballots in a voting protocol will be signed to show that they are authorized by the voter.

In privacy-respecting digital asset protocols, signatures are often ambiguous, and you can't necessarily identify the signer, but you know that the signature itself is somehow valid. And we'll have the same thing in a digital voting protocol, where signatures will be ambiguous in order to provide voter privacy.

In privacy-respecting digital asset protocols, you often have amounts and other details are encrypted. And they're encrypted in such a way that they can still be verified to have properties like transaction balance, where you haven't constructed money out of thin air. In a digital voting protocol, we'll have these selections, that is, which candidates or options are being chosen in the ballot, be encrypted in a similar kind of structured way so that we can reason about them.

In a digital asset protocol, we need transactions, of course, to be verifiable, to show that nothing went wrong, that they follow all the rules of the protocol, whatever those might be. And we want the same thing in a digital voting protocol, where we need the ballots to be verifiable in such a way that we know that the election was conducted honestly.

And finally, in a digital asset protocol, we want to reject double spends. So if I try to spend funds in one transaction and again in another, that double spend should be rejected. Otherwise, we've constructed money out of thin air. And similarly, we typically want to reject double votes, but I'll have more to say about that later.

So Aura is one design for doing this. There have been a lot of different designs, many of which have a lot of trade-offs. But Aura is the design that my co-author and I came up with that is a privacy-respecting digital voting protocol using many of these digital asset techniques that we talked about that does these things, that meets the goals, we think.

So there's several players involved in this to conduct an election. The first one is going to be the organizer. So that's the entity that's going to set up the election, what's going to be voted on, what the selections are, who's going to tally the votes at the end. Oftentimes you'll want multiple talliers so that if one tallier turns evil, they can't do as much damage, and which voters are permitted to vote in the election. These, of course, all of these things can vary widely depending on what election you're talking about.

The voter, of course, is going to cast a ballot in the election. The tallier is going to be one of possibly a group of entities that's going to count the ballots in order to obtain the election results. And finally, a verifier could be anybody. Oftentimes, you'd want it to be anyone, whether or not they participated in the election, any network observer or participant. They should be able to check that the election results are valid.

So first, let's look at the property we talked about called ballot privacy, which says that we need to make sure that nobody can see by looking at a ballot on the ledger what selections the voter chose. So the way that we do this, and I promise there will be no math here, but I will use one cryptographic term, which is ElGamal encryption. There's many different ways to encrypt data one of which is called ElGamal encryption. ElGamal encryption is used all over the place in part because it has a very specific structure that allows us to reason about things that we're encrypting. So the voter uses this ElGamal encryption to encrypt the selection for every option on the ballot. And they do it in such a way that only the tallying entities, the talliers, the counters, can decrypt it later. And we'll talk more about what that means in a little bit.

But what this means is if my election is to vote between Alice, Bob, Charlie, Dana, or Eve, maybe the voter wants to choose Bob, but the voter is not simply going to put that into a ballot and just throw it up onto the ledger. That would immediately break ballot privacy. So instead what the voter does is they encrypt the choice for Alice, which would be "no", or typically zero in ElGamal, into this blob that no one but the talliers can decrypt. For Bob, I would encrypt the vote "yes". For Charlie, Dana, and Eve - "no". But to an outside observer, all of these just look like a locked blob.

But we need to make sure that the voter didn't select more options than allowed. If I just select "yes" to everyone or "no" to everyone, that might not be allowed in the election. So we need to make sure that the voter didn't select more options than allowed and make sure that they actually encrypted the ballot so that the counters can decrypt it later, and they didn't just throw random nonce onto the blockchain.

So we actually include two separate zero-knowledge proofs, one of which proves in zero-knowledge that the ballot contains precisely the allowed number of selections. In our example, that allowed number was one, Bob in this case, but in other elections you might be allowed to vote for multiple candidates. Depends on the rules. But we can show that the ballot contains the allowed number of selections, no more no less. And we can prove in zero-knowledge that the ballot is properly encrypted to the talliers, and both of these are possible because of the very structured way that this ElGamal encryption works. So this is great because an invalid ballot can be rejected from the ledger before it even goes on there, and any verifier can check these proofs to show that these properties hold.

But how do we do voter privacy? That is, we know that we can't see what's on the ballot, although the selections are valid, but how do we know that the ballot was cast by an allowed voter without identifying who that voter is? Again, we can use some techniques from privacy-respecting digital asset protocols in order to ensure that nobody can see who cast the ballot. So every ballot is signed that's using something sort of like how we do linkable ring signatures in Monero and other asset protocols.

So it shows several things. It shows first that the signer is on the list of allowed voters, which remember the organizers set up at the very beginning of the election. These are all the voters who are allowed to cast a ballot in this election. We can show that the signer of the ballot is on that list. We can of course also show kind of with that, that the signer actually authorizes the ballot to be cast and that it wasn't manipulated in any way. And we can also show using the linkability property of some of these ring signature and related constructions and cryptography, that the voter hasn't cast a ballot before to avoid this double voting process. So, and importantly, with all these properties, with the signature and the ballot, it's not possible to determine which voter actually signed it. So you get a lot of really neat things. And again, this is all very similar, as we mentioned before, to what privacy-respecting digital asset protocols provide.

So similarly to before, an invalid ballot can be immediately rejected from the ledger because of these specific signature. And as before, any verifier can check this after the election to show that these properties hold.

Now what's really interesting about this is the tallying process. So far we've only talked about casting ballots, but we want to make sure that the tallyers can accurately count the ballots and provide a result in the election without identifying anything about individual ballots. Nobody should be able to tell by looking at a ballot again who signed it or what was in it. But we also said before that these encrypted selections for a ballot are encrypted so that the tallyers can decrypt. So how do we make this work?

So after the election, the talliers have to count the ballots to obtain these results. But like I said, because they're not allowed to see the selection for any particular ballot, they do the following things.

The first thing they do, as I'm putting this in quotes, is they "add up" the encrypted ballots. And because we have this very nicely structured ElGamal encryption, the talliers can literally take from each ballot all of the Alice encryptions and add them up in a cryptographic way, all the Bob selections add them up and so on for every option. And then what they'll do is they will collaboratively, as I said, it's often the case that you'd want multiple talliers to exist such that one of them can't do much damage, that you need a group to do this, they'll collaboratively decrypt only the sum of all of these ballots. So all of the Alice's summed up, the Bob's, the Charlie's, and so on. And finally, once they've done that collaborative decryption, they can then publish the total votes for each option - the total selections for Alice, for Bob, for Charlie, and so on. And I mentioned this collaborative aspect because we use a specific kind of collaborative and verifiable decryption.

And this is possible because every single tallier doesn't contain the full key to decrypt ballots. They only have a portion of it. We use a very special kind of threshold verifiable scheme to do this. So an individual tallier can't decrypt anything alone, but can only do so with this group of talliers, which ideally minimizes trust because you need all the talliers to turn evil in order for something bad to happen.

And of course, as before, this collaborative decryption also includes a proof that all of these totals are correct. So anyone can verify that this decryption happened honestly.

I also mentioned trust minimization. And we said that we kind of want to reduce the so-called blast radius for the effects of either evil or colluding organizers or talliers. So just as a reminder, the organizers set up the election and the talliers, as well as select the allowed voters. And we said the talliers are going to collaboratively compute and then decrypt the election results to publish them.

So a couple of comments on why we can do trust minimization. On the organizer side, the way Aura is constructed means that while the organizer can select the allowed voters, it doesn't control the keys that the voters use to compute, sign, and publish their ballots. So it can't really do a whole lot once it's set up the election. And further, all of the operations that are used in the setup of the election are verifiable. So the organizer has very little opportunity to try to scam folks.

And as we said about the talliers, An individual tallier doesn't hold the full key to decrypt any ballots of any kind, so it can't do any decryption on its own, because it doesn't have that full key. A group of talliers could decrypt individual ballots if they were to collude, which would be bad - they'd be able to see the results and selections of those individual ballots - but they still would not be able to determine which voter cast it. So there's a kind of a little bit of a blast radius there around the tallying authorities, but ideally not much.

There's some other tricks that the protocol can do that are kind of nice depending on what properties you want. The first is no trusted setup. A lot of other constructions kind of subtly or explicitly require a trusted setup in some of the cryptographic constructions. Aura doesn't. All the plumbing that's used cryptographically can be computed and constructed openly and verifiably. That's nice.

Coercion resistance is actually a really subtle property. What you don't want is for there to be incentives for someone to coerce a voter into voting a particular way or to try to bribe them and just pay them off to vote a certain way. This is actually really, really challenging in digital voting schemes. Coercion and bribery could happen because the coercer or the briber could say: "Okay, vote the way that I demand or pay you to vote and then show me, because this is cryptographic, prove to me that you actually voted that way". That's very hard to avoid.

There's a version of Aura that you can kind of construct in a modified way that can minimize these risks by actually allowing a voter to vote multiple times. Now we said we don't want double voting, but it turns out you can modify Aura such that a voter can vote multiple times, but in such a way that when the tallying is being computed, only one, the most recent vote, is counted. And ideally that helps to at least somewhat mitigate the risks of coercion or bribery, because if someone pays you to vote the way that they want, and you prove that you did it, you can just go back later and secretly vote the way you actually want to.

So, it's not a perfect scheme and there's different ways to achieve or at least try to achieve coercion resistance. But Aura has one that I think is a fairly good trade off.

The third one is the tallier key setup. I mentioned that each tallier only holds a portion of the key required to do any kind of valid decryption. But we can do this in a very safe and verifiable way. If you don't do it in a safe and verifiable way, it's unclear what the consequences could be of possibly having too few talliers be needed in order to do decryption, but we can do a very nice, robust setup for the tally or key.

And finally, I did mention somewhat briefly that not every election would have the same selection rules as the one that we kind of used as an example, where you have several candidates and you only get to vote for one. It turns out we can modify our little bit to support kind of both a minimum and maximum number of selections in an election. So, maybe you have a number of candidates and you have to vote for at least three, but no more than, I don't know, five or something. We can construct Aura in a way that this can be done in a verifiable fashion. So there's a lot of flexibility.

There's a lot that I did not talk about, and I did not talk at all about the details of the protocol, which I promise you would not want me to do here, but there's a preprint on the ia.cr archive, which is there, and there's also a repository with all the tech stores for the preprint. These slides will be up on GitHub after the event. So feel free to go and check them out if you want. And my email is up there as well. I'd be happy to answer any questions. Thank you.
