# Compunero, PhD

_**A Primer on Elliptic Curve Cryptography and Its Application in Monero**_

_This talk is an introduction to Elliptic Curve Cryptography (ECC). Attendees are expected to have a basic to intermediate understanding of the field._

_To begin, we will cover the basic principles of asymmetric cryptography. We then discuss ECC curves and security, along with a comparison of asymmetric non-ECC with ECC. Finally, we will cover the mathematical principles behind ECC, including the fundamental mathematical operations, and how elliptic curves are applied in Monero's cryptographic mechanisms._

_Email for questions: compunerophd@proton.me_

[https://youtu.be/2OpovwMbfGY](https://youtu.be/2OpovwMbfGY)

---

_**Moderator:**_

Jay was a career in both tech companies and academia, led them to focus on cloud security, machine learning, behavioral analytics, and now to work on private cloud management. So this talk will take you from the basic principles of asymmetric cryptography to the ways elliptic curves are applied in Monero's cryptographic mechanisms. So Jay, the stage is yours.

_**Jay:**_

Thank you.

So thanks everyone for coming. So in the next 20 minutes or so, we'll just talk about - that's fine, I guess - so we'll just talk about certain concepts in the elliptic curves and how they are used to construct the Monero address. So this talk is not intended to be too deep in the math. And it's just intended to give you some certain concepts to hopefully understand them whether you have a good background, deep background, or whether this is the first time you're hearing about elliptic curves.

So elliptic curves - this is the general formula for elliptic curves. Elliptic curves is not just one curve. It's a family of curves. And as you can see, those two parameters, a and b, are the certain values that a and b are the values that specify the curve shape and therefore the properties of this curve.

So this is a bunch of some samples of those curves. So as you can see on the left side, this is a and b. So these are various values for a and b and how the curve will look like. So again, when we say elliptic curve is not just one curve, it's a family of curves. And then people will go and take certain values for a and b and specify, study, prove some certain use cases for those curves.

Then there is another terminology here, which is what we call a "field". And the field is essentially the combination of the values of a and b, or the permitted values of a and b. So that is another concept that is known in this regard.

So now there are a couple operations that we want to talk about. And those are very essential when talking about elliptic curves. One is known as "addition operation", and the other is the "duplication operation", or "multiplication operation". So multiplication is technically a bunch of additions. So when you say 5 times 2, it means 5 plus 5. So that's the basic concept. So when we talk about multiplication, we are technically talking addition. When we talk about duplication, we are also talking about addition, because duplication of a is essentially a plus a. So everything is explained within the notion of addition. What we're going to do over the next few slides is to go over the concept of addition, try to understand how the elliptic curve performed the addition.

So first, when we have one single point on the curve, and let's say the point g here, it's a random point on the curve. And we have this curve with a certain a and b parameters. This is an elliptic curve, one instance of elliptic curve. Now, if you want to take this g and add another g to it, so we want to compute 2g out of this g, essentially, you want to say g + g, or we are duplicating g into 2g.

So the steps in the elliptic curve is that you take the tangent, which is the straight line that touches that point, and this tangent is guaranteed in the elliptic curves to cross the elliptic curve only in one other point. So this tangent here will cross in this point, and then step two we take the reflection of this point into the other side of the x and then that becomes 2g. So the addition operation in the elliptic curve in general is performed in this manner - you take a point, take a tangent of this point, and then you take the reflection on the x, over the x, and that gives you the 2g.

So let's take another example. So now we have two points, not one point, two points, g and 2g, and we want to produce 3g out of it. So the process in elliptic curves is that you take the line between g and 2g, the straight line, and that's only one line, right? This line is guaranteed to cross the elliptic curve in only one spot, one point. And that's where we see here - when we do the cross, the cross goes up to this point and then we take the reflection over the x and that becomes 3g.

One more example, which is how to get number 4g. So here we have number one g and 3g. And we want to produce 4, which is 1 + 3. And the process is you just draw the line between 1 and 3. And then you find the cross point, which is guaranteed to be only one single point. And then you reflect that on the x-axis, and that's where you get 4g. So you see those four points are essentially originating from one single quote unquote seed point, which we are calling g here.

So as you can see, as you are adding, first you pick one point on the curve. And then you are adding this point to itself as many times as you want. And you are technically always on this curve. So you're technically moving as if you are moving randomly on this curve. That's the idea.

So now the next step into this addition is that the addition is not just, you know, just say, if I want to produce 10g, I will not go and add 1g, 1g every time so that it costs me nine operations. I would do it a bit more smarter. I would take g and g, and then that would reduce 2g. And then I'd take 2g and 2g, that would give me 4g, right? Because the duplication operation is as costly as one addition operation in this manner. And therefore, I can end up with 10g in four steps. So that's another kind of one of those features of the elliptic curves. Because always in the basic mathematics, always ng + rg, not necessarily the same number, will just in the basic math, (n + r)g. Even though it's not. Technically, you're adding g as an absolute number to another g. It's an elliptic curve addition method.

So now elliptic curve, as we said, is quite a gigantic field in cryptography. And there are so many different techniques out in the literature. And the specific one that's used in Monero, there's one curve that's specifically used for Monero address generation, and it is part of a family in the twisted Edwards curve. So there's a family called "Edwards Curves". And out of that, there's the "Twisted Edwards Curves". And one of those is the one that's being used by Monero. And we'll talk about this specifically.

This is the specific curve. So as you can see, this goes under the umbrella of elliptic curve following the first equation that we saw. It has certain parameters for a and b and a set of additional concepts or parameters or values that are set specifically for this curve. The field defined over this specific curve, which we call Ed25519, the field is over those values, 2255 â€“ 19. And you can see, if you forget the name, the name comes from the field definition. So 19 is a prime number, and 25519, that's where this name comes from.

So now let's pivot onto the asymmetric cryptography, because we wanna build some concept toward building the Monero address ultimately. So as a refresher, asymmetric cryptography comes from, the word "asymmetric" comes from that you have two different keys, right? One on the encryption side, one on the decryption side. And usually in the literature of the cryptography, they use the names Bob and Alice that they are kinda communicating. And the whole concept of asymmetric cryptography is that you are establishing a shared secret over, or trying to communicate a shared secret over an unsecured medium. So the channel that you are communicating with using this channel is unsecured. And you are kind of establishing some secure protocol to do that. That's the basic idea. And there's always a public key and a private key. So if Bob wants to send a message to Alice, Alice has a private key and a corresponding public key from this private key that she shared publicly. And then Bob uses her public key in order to encrypt the message. And then they will communicate this encrypted message using unsecured medium, and then that gets decrypted using a certain algorithm with this private key. That's the basic concept of asymmetric cryptography.

So now, in the context of elliptic curves, when we apply it to the asymmetric cryptography, Alice will have a seed value. We call it G, which is a shared value - Alice and Bob and everyone in the world knows this value. Alice has a private key, and only Alice has this number. It's just an integer, a number of a certain length, depending on the curve or the application that we're using. And then the public key is just a multiplication of b times G, which we just discussed. In the elliptic curve, in a word, when you say b times G, it means that you are adding G to itself b times. So it is multiplication in the elliptic curve definition, which is just saying G plus G plus G b times. And the same concept on Bob's side. He has, he has - G is short, it's the same - he has his own private key. He doesn't share that, but he shares the public key, which is technically just adding G to itself, the number of the private key that Bob has.

And then there is a final computed sort of key that will be used to decrypt. This is slightly different from the concept that we talked about before - they do use a computed value, and this computed value is a combination. So it says a times b times G. So a from Bob, he knows that. b times G is already shared by Alice because that's a public key. So now Bob is able to generate abG. Alice on the other hand is able also to generate the exact same value because she has b and she has also a times G and that will end up with abG. So only Alice and Bob can generate abG given that they have something special which is that the private key of their own.

So now, again, in the traditional techniques that do not use elliptic curves, such as Diffie-Hellman, which is a known algorithm RSA and those families, I wanted to kind of bring both of them side by side with an elliptic curve, kind of high-level concepts so that you see the differences.

So the shared G, which is some seed values, those are common between the two. A private value, so it's some value that's private to Bob, private to Alice, the same thing in the elliptic curve, a and b. Now, the public key is usually generated with the notion of power. So you say some value to the power of this private key. And the same thing for Alice public key, it becomes G to the power of b. And it all comes down to the concept of that G to the power ab is the same value as G to the power ba. That's the basic concept in math, because for, let's say, Bob, he has G to the power a, but now he needs to multiply that with, sorry, he has G to the power b, and now he needs to have that to the power a. And because of this, they are able to compute the same value.

On the elliptic curve side, the computed is ab times G. Now, if you notice, this is to the power, and this is just a simple multiplication, which is essentially adding G that many times. And that is where we get a way much shorter key. In some cases, it's an order of magnitude. So you say four digit, or let's say, for decimal digits, let's say 2,800 something on this side is equal to 200 something on this side, right? So there are some certain use cases around that. So it's way much shorter, key with the same level of complexity, the same level of security.

So downsides of the EC in general. So many are patented. So as we said, researchers will take a certain, you know, parameters for the elliptic curve, that obey their elliptic curve, and then they will go patented. So many of those have been patented over the years.

Unlike the RSA, it fails without sufficient randomness. So for the generation of the private key, if you don't generate it using some true randomness, it might end up failing. So there's a high dependency on the randomness of the key generation algorithm that's being used.

Some of these curves that have been in the literature where it can have some kind of being suspected or found out that they are compromised or having some trap doors. And there's one that was detected that has a possibility of a trap door. This was promoted in 2006 and then was withdrawn in 2014. So this also is another one of those caveats in the usage of EC.

And of course, the theoretical foundation is quite more complicated than traditional techniques.

Now, until now, or this talk is not about certain algorithms, right? So we did not discuss certain algorithms about how to generate the key and all that. It's much more complicated and it's more math. That's not the purpose today. But I kind of brought up certain concepts to explain the ideas. And there's one more idea, which is the modulus operation. I want to make sure that we convey this too. Because the modulus is just used everywhere. And whenever there's a cryptography, they just use the modulus operation.

And I wanted to make sure that this is clear. For example, in this formula, when you say 2 to the power n equals 16, this is pretty straightforward symbol, right? You say immediately n equals four. But once you add the modulus you cannot even tell what n is, right? Because with this symbol operation, even though the basic is the same, but now to the power n, this could be 16, because the mod is 16, right? The answer is 16. So this could become 16, and then n is 4. But then it cycles around, right? So at 16, 17, you get 33. And then what is n when 2 to the power n equals 33? You figure out what that n is, right? And then you keep cycling it. So it's not a deterministic answer. So I want to make sure that this is conveyed now. That's why the modulus is used in this context.

Now, the specific use case for Monero, we're going to take the Monero address generation, just to kind of wrap up. So this is the specific curve, the Twisted Edward's Curve 25519. That specific curve that's used for generation of the Monero address. This is the field. So these are the total points. 2255 minus 19. The total points that are possible to pick from for our private key and public key, so our private key. And then accordingly the public key, because the public key is technically private key multiplied by certain, by G. And G is fixed, I brought this number in here to make sure that you understand that G is not hidden - it's known and it's public. And it's a certain number and this is the number. And then there's an additional number which is l, which is a prime number and that's the specific number right here. And this number is the value that we use for the modulus operation that we just mentioned. So throughout the process there's a modulus at multiple stages, and the l that you mod to, is the value that you mod to is l, and this is the value. So technically the private keys that you are generating will end up between 0 and this value minus 1, because it's the value that you are always more.

Now, the Monero address specifically, of course, is more complicated than this talk. But there are three types of addresses - standard, subaddress, and integrated. We'll take just the standard address, which is known as the raw address.

The raw address consists of four pieces of information. One is the public spend key. One is the public view key. And there's a network byte and the checksum. We'll just focus on the first two. But let's talk about all of them in general.

So Monero address is 69 bytes, and that is the specific pieces of it. The first byte is reserved for what is known as network type, and those are redefined values. There's 32 bytes for what is known as public spend key, and there's another 32 byte for what's known as public view key, and then there is a checksum that's essentially just 4 bytes generated from those 65 bytes using some hashing function. And then we take those 69 bytes, we use a certain encoding algorithm known as Base58, and then that will end up with 95 characters, which essentially represent the row address. And this is an example of the address, I'm sure every one of you saw some example like this.

So the network type. There are two main values. The first one is 18, which is 12 in hexadecimal, and this is 53 for the test, right? So either the main or the test, or you can generate something else. But those are the two main things that are known for the first byte.

And then that is the piece that you wanna connect here. So there are, again, we are not talking about certain algorithms, talking in general. So ideally, we create two private keys, let's call them a and b. One is gonna be used to create this public spend key, which is technically a times G, connecting to the elliptic curve, and the public view key, b times G. And then in the middle of this operation, you always have to restrict yourself to that l, which is also redefined by the mod operation.

Now in reality, we don't generate two separate private keys, we just generate one in order to create the public spend key. And then using that, we hash it in order to create the other private key, and from that we create the public view key for the address. And the address is a symbolized, but this is again, not certain algorithm, but the address, ultimately, is just stitching or concatenating all of these values together. And then you do the Monero Base58. The Base58 is a certain algorithm that essentially just picked 58 characters. And all the letters will be encoded with 58 characters. Usually, we use 64. But 58 is used here, and I kind of highlighted the ones that are eliminated - the zero, the I, the O, and the little l. And the reasoning is that those characters are confusing with each other. So the I is usually confused with little l, that's why they are both removed. And the zero and the O are usually confused with each other, that's why they are removed. And that's where the Base58 comes, you know, and became quite popular for that specific reason.

And the last part of it is the checksum, which is, takes just 65 bytes and then generate a certain hash, the first four bytes for the checksum.

And so that's about it. Some readings for, you know, where this talk coming from in terms of the resources. And hopefully this was quite helpful in terms of understanding how the Monero address is created.

Thanks everyone if you have any questions.
