# Sowle

_**Implementing Confidential Assets in PoW/PoS Private Blockchain: The Zano Experience**_

_In the presentation, we detail the integration of confidential assets within the Zano blockchain. This initiative enables anonymous asset transfers and asset swaps (referred to as 'Ionic swaps') involving multiple asset types within a single transaction. Additionally, we will discuss how Confidential Assets are combined with Zarcanum, a Proof-of-Stake scheme, to facilitate egalitarian and anonymous staking with hidden amounts._

[https://youtu.be/OcoS-pi3Xms](https://youtu.be/OcoS-pi3Xms)

---

_**Sowle:**_ Hi everyone. I'm going to talk about implementing confidential assets in Zano. And what confidential asset basically is, it's just a tokens that we can deploy and transfer in an anonymous way. So that's what my presentation about. And I'm sorry, it's going to be a little bit technical.

So in brief introduction, my name is Val. I also may be known as "crypto sowle". I'm a lead researcher at Zano and also I'm also author of Zarcanum. Last year together with koe, the developer of Monero, we presented this Zarcanum at MoneroKon and previously at Monerotopia.

So, what was the motivation? Stepping back over a year and a half, what we had at Zano, we had a CryptoNote-based, L1 blockchain, proof of work and proof of stake hybrid consensus. We had Zarcanum private proof of stake concept implemented in testnet and we was ready to implement it in the mainnet. And at that point we thought that maybe it will be interesting to implement Multi-Assets on our blockchain. We started to explore this field and we basically wanted to implement Multi-Asset support, of course, with a hidden amount and maybe also with a hidden asset type so the external observer can't guess what assets are being transferred. Also we would like to have a unified anonymity pool for all our outputs in the blockchain. So we don't end up with a situation where we have one output for one asset, one output for another asset, and another set of outputs for staking, for instance. So we would like to have it unified.

And we actually found that quite a few work actually were made on this field. You can see it's quite an effort. Here I would like to mention some work. First of all, it's "Confidential Assets" by Andrew Poelstra, Adam Back, Mark Freidenbach, Gregory Maxwell, and Peter Wuille. In 2017 the concept was introduced and later it was, I believe it was implemented and it was a paper called "Liquid: a Bitcoin Sidechain" by Jonas Nick, Andrew Poelstra, and Gregory Sanders. So these two works, as far as I know, from guys, from persons and researchers from Blockstream company. Then it was a paper called "Lelantus-CLA" by Pyrros Chaidos and Vladislav Gelfer, which more improve this concept and also I would like to mention the "Spats: Confidential Assets and Non-Fungible Tokens" by Aaron and Aram that was also presented last year on the MoneroKon, and two days ago we saw a nice presentation of "Bulletproof++" by Liam. This is, as far as I know, work again by people from Blockstream and relative to Blockstream.

So quite a few effort on this field, and actually funny enough when we first started to thinking over how we could implement confidential assets in Zano we came up with two ideas how this could be done. And later funny we find out that both of these ideas are more or less presented by researchers in different work. So we stick to one. Our approach mostly following the approach by Confidential Assets by Andrew Poelstra.

So I would like to go, before I go deep into details how we actually implement it and which changes we faced, I would like to very briefly recall how actually classic CryptoNote and Ring Confidential Transactions look like. And after that, I gonna show what changes we made to make it compatible with Confidential Assets.

So in classical CryptoNote we have just in plain amount a - it's not hidden. It is put on the output and everyone can see it. On the Ring Confidential Transactions we have amount commitment output are not seen by everyone anymore and it committed to Pedersen commitment using randomness f, and here is the amount a that we have. And what basic idea that we have for Confidential Assets is that we use different generators for amounts for different type of assets. So this is very basic concept. And instead of providing the asset type, actually asset generator that we use for this concrete output, we have to hide this using another commitment, using another randomness, different randomness error. So basically we have a generator that is - it's so-called asset tag in one work, in another work, it called asset ID, I believe - and here we have a commitment to an asset, or, I'm sorry, we have a commitment to an asset, and also it is called blinded asset tag. So external observer cannot guess, looking at this output, cannot guess what actually type of asset being transferred.

This very basic idea. So now I would like to consider the transaction structure of CryptoNote and RingCT. So in CryptoNote we have just a plain - this is very simple transaction structure - we have one input, one output. For each of output we have only stealth address and plain output, plain amount placed here. And for one input we have here input referring to a set of another outputs that is known as decoy set, only one of each is actually being spent - some of like using index π - and external observer cannot tell, cannot guess which one actually being spent. But for sure sender of the transaction knows it. He knows or he knows the secret, I'm sorry, secret part for stealth address. So only we need to do to implement this approach is to use a classic ring signature to proof in zero knowledge that we actually know the secret part for one of the output referring here.

In real world, of course, we have a transaction with several input and several output and base balance proof can be done very easily, very natively by just assuming amounts on the input side and output side and making sure that we are not creating any new coins.

When RingCT came up, outputs don't contain plain explicit amounts anymore. Instead, it contains amount commitment. And this amount commitment, else they put in each output. And here we have the same structure as before - one input referring to a set of outputs, only one of each is being actually spent. And sender knows all secret part for stealth address and for amount commitment. He knows amount a and he knows randomness f that was used.

Unfortunately this amount commitment can be used in other proofs in this transaction, because it will immediately be clear which output actually are used here if we use like this amount commitment. So to overcome this difficulty RingCT use approach called "pseudo output commitment". So we just generate another commitment to the very same amount a that we have in this input, but using different randomness. And this amount commitment are put in the transaction data plainly and this amount of commitment are used subsequently in proofs. And to do this possible, we only need to add another layer to the ring signature. It's very important that we don't use another ring signature, but we use another layer of the existing ring signature, because we need to proof zero knowledge that for very same index π, secret index π, one of the output here have, have stealth address and amount commitment that satisfy this equation. So basically sender knows for some output knows secret part for all of them, but nobody knows for which one.

And of course in real world situation we have few outputs and few inputs and due to the, thanks to the homomorphic property of Pedersen commitment, we can sum up the commitments instead of summing out the amount itself. And of course we need to account for fee. Fee in case of the RingCT should be placed explicitly in the transaction extra, I believe. And we should account for old outputs from the previous era that was generated years ago and still using plain outputs.

Now I would like to show what changes we made. So all that I said before is what actually ring signature, RingCT looks like and it's used in Monero at that point. And now I'd like to show what changes we made to make Confidential Assets possible in this scheme.

Here basically we for each output we along with output commitment we need to put asset commitments. And so this structure pretty much the same. Only change we need here is that we need to generate another pseudo- output commitment to an asset that is actually used. And here we have third layer of the ring signature, because we need to prove in zero knowledge that the sender of the transaction actually knows all these secret data and these pseudo-output commitments are well formed.

And here we have a challenge because we can't use classical CLSAC approach here because we have three layers and two different generators here. We could use MLSAC for instance, but we decided that we rather try to modify existing CLSAC scheme because of effectiveness. And we did it. We came up with a scheme that's called dv-CLSAC. This is just an extension that allows to use different generators in CLSAC. And this paper is published and I'm very grateful to Cypher Stack and Aaron for reviewing it.

Yeah, as before we have in real-world situation we have several inputs, several outputs and we still can check balance by sum all the commitments output commitments on the input side and on the output side. And as before we need to account for a fee and as before we need to account for very old outputs with explicit amounts that was in existence like years before, in Zano we have plenty of them.

Yes, and here we have kind of problem, because we need to somehow make sure that these output commitments in the outputs are well formed. Because basically in RingCT we have range proofs that make sure that, I'm sorry, that make sure that, [oh, it works] that make sure that all these output commitments are well formed. And for asset commitment, we actually need so-called assets surjection proof, because otherwise an attacker would use malicious generator over here and will be able to generate coins out of thin air. So basically we need to prove, with zero knowledge of course, that for each output, the generator that used for asset here corresponds to one of the input. It could be done by using just plain ring signature as it was proposed by the original work "Confidential assets" by Andrew Poelstra et al. And we decided to try different approach, more effective space-wise and we ended up actually implemented an "1-out-of-N" modification of the algorithmic membership proof that was introduced and discussed and improved in series of works.

And here I'm showing three papers that we actually used. Unfortunately, I didn't find a single paper that actually have all these improvements in one single space, because it would be very convenient. I'm actually thinking about maybe writing such a paper, because it would be convenient for other. So we ended up using a logarithmic one out of hand proof that space wise has size of 4log,m plus four elements.

Also, there is another challenge using range proofs in such a transaction scheme. It makes it for us impossible to use range proof aggregation, because Bulletproofs+ and Bulletproofs very conveniently provides an aggregation. So you can use not one range proof for each output, can use, combine it all together and provide only one proof per transaction. It saves lots of data. And here we have a difficulty because this approach requires using constant generator for amount and for randomness. And here our approach don't allow this.

To overcome this difficulty, we decided to provide additional, for each output provide additional commitment using another fixed generator U that is have no efficiently computable algorithmic relation with all other generator of course. And yeah, we could prove in zero knowledge very easily that these commitments are committed to this very same amount. And then after that we can use range proof aggregation. So we save a lot of data using this approach.

Okay, so here we discussed basically a transaction structure that allows to transfer confidential asset from one user to another user. And we made sure that no coins are generated out of thin air, but how assets could be emitted in the first place. And we've done this by publishing a special structure publicly in the blockchain. For instance, if I would like to emit an asset, I register this asset, I put special data structure, we call it "asset descriptor" - put the ticker name, supply, decimal point, all the necessary information. And also I put the public key that will in future allow to control the asset. All this data is being hashed and at the end we have a random elliptic curve point that will be used as an amount generator, asset tag so called.

And each time when I as an asset owner need to emit asset or burn publicly burn asset or to modify kind of metadata, I need to provide ownership proof. And returning back to the transaction scheme that we considered, so all we need to do is to put this information to the transaction extra along with the amount commitment that it used to emit an asset and to account it in balance proof equation over there. So, and this works.

A few words about Ionic Swaps. This is concept that I think dates back to the 2013 to CoinJoin idea by Gregory Maxwell that basically consists of that one user can create a partially signed transaction and pass it to another user who will complete the transaction and after that this transaction will be broadcasted. So conveniently enough this approach with these confidential assets allows to instantly swapping asset between user.

For instance, in this example, Alice would like to swap the orange asset, let's call it that, to violet asset, and she creates the partial transaction that only has an input that she has and output that she would like to receive. And that this transaction is being sent to the Bob, for instance, who would like to interact with Alice and to change these assets. And Bob completes the transaction by providing the inputs for the required outputs over there and outputs for himself. So now this transaction is complete, could be broadcasted, and very easily and conveniently, two persons could instantly exchange their asset entirely on the blockchain in a private way - that's important because external observer couldn't guess what actual asset type are being used here and being exchanged.

And like just a few words about the Zarkanum. When we implemented all that I told before, we came up with another challenge that we don't like user to stake asset instead of native coins. We would like them to only stake native coins. And Zarkanum transaction scheme was developed way before we came up with a confidential asset solution. So we need somehow to integrate one with another. And this is how we did it. I won't go into the details about how Zarkanum work, but what we see here is just a proof of stake mining transaction. And Zarkanum requires an additional commitment to be put in each output and additional pseudo output commitments to put over there. So we just ended up with adding two layers for the ring signature. And now we, for Zarkanum mining transaction, we are using 5/2 CLSAC, because it's five layers and only two distinct generators here is used.

And yeah, it works. It works. But like we have interesting, very interesting anonymity issue, because as I said before on the transaction we have this blinded asset types, so external observer cannot say which actually asset are hidden over there. So we don't know is it native coins or like USDT or rapid Bitcoin. But in this particular transaction on the left side, on the input side, we have only native coins obviously because we could only stake native coins. And on the output side we have like potentially hidden assets. But in this situation it's obvious that all these hidden assets would be native coins, because if you have only native coins on inputs you should have only native coins on outputs, if you don't emit an asset and this is not the case. And this would be not nice for anonymity, because we would like, as I said before, we would like that all that output pool would be unified. And we would like that in a perfect world, all the outputs would have as little information about the asset types as possible.

And to overcome this, we just can modify a little bit this transaction by providing another input. So here we have a stake input for native coins and here we have just arbitrary input from the user's wallet. For instance, it could be whatever, whatever it possible. And after that here we have really hidden transaction asset types because now external observer cannot guess which one is native coins and which one is, is not. It's very convenient.

So what actually we done using this? We implemented all this confidential assets scheme, and it's live on the mainnet since March 21st, on Zano, we called it Zarkanum hard fork. Also, this Zarkanum hard fork introduces the Zarkanum proof of stake, so now we have along with confidential assets, so everyone can emit this asset and use it. Also we have a private proof of stake. So if you stake your coins in Zano, so no external observer can guess how many coins do you have and so on. And yes, everyone can deploy, manage, burn the asset. And Ionic Swaps now are implemented in Zano wallets. So as in my example, Alice and Bob could participate, could discuss this transaction and actually swap assets on chain. And also, yes, I said before, we published a paper on the CLSAG extension and it was reviewed by Cypher Stack.

So that's pretty much it. Thank you very much.
