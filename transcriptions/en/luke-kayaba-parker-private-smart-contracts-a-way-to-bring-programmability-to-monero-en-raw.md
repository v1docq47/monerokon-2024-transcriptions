# Luke 'Kayaba' Parker

_**Приватные смарт-контракты: способ обеспечения программируемости Monero**_

_Smart contracts are a frequent request for Monero, yet have significant questions about privacy, efficiency, and complexity. Any VM would have several pages for its specification, with opcodes debatable for years. The denial of service risk would threaten Monero's stability, and the lack of privacy seen with most VMs would be unacceptable._

_This talk will establish and go over a potential evolution for the protocol, where smart contracts are expressed in algebraic terms (creating a pure specification) and evaluated in constant time (being without a denial of service risk) while maintaining privacy of the contract code, inputs, and execution without a trusted setup._

[https://youtu.be/5pGR03Fj5FE](https://youtu.be/5pGR03Fj5FE)

---

_**Luke:**_ Hello everyone! My name's Luke Parker, also known as kayaba or kayabaNerve. I'm going to go through the full introduction today, so I apologize to anyone for who it's their third time, but you know — new day. I'm the developer of Full Chain Membership Proofs and the "plus-plus" variant, along with Serai, a decentralized exchange for Monero, Bitcoin, and Ethereum. I'm also a MAGIC Monero Fund committee member, so if you are subject to US taxation, and want to donate to Monero development and get a tax deduction for that — MAGIC! I'm also privileged to be a five-time speaker at MoneroKon now, really going for that number, so yeah.

So I just want to start this off with a very large disclaimer. So no one claims: "I'm promising things that never materialize. No one's working on this. Don't expect this. If you want this, wait at least 10 years. Maybe throw me a few million in R&D money". Yeah, it's an interesting enough topic. I want to approach it, and I want it to be considered when we discuss future upgrades, such as when we move to post-quantum technology, and already have to rewrite large swaps of the protocol, but it's not something on any short-term, immediate, or even next upgrade roadmap.

So smart contracts. Just for anyone who isn't aware, they're autonomously executed programs. So if you want to have something done, and you don't want to rely on a human who is slow and might fail to do their job to do it, you can ask a smart contract to do it for you, and it will just do it. It enables most of the decentralized finance, let's go with craze that we see over taking cryptocurrency, all of these Ethereum apps, those are almost all smart contracts. They enable decentralized exchanges without additional trust assumptions, so on and so on.

In the case of Ethereum, they've also enabled privacy protocols to be built, such as Railgun, which allows you to shield your Ether and send it privately without anyone seeing it. Because while Ether does not have native privacy, because smart contracts are turning complete, they can themselves implement privacy protocols.

It also enables trust-minimized bridges. You can have a smart contract which evaluates the Bitcoin state and looks for certain forms that Bitcoin locks. And then if Bitcoin also had smart contracts, it could release that Bitcoin in response to certain events on, say, Ethereum or Monero.

And then what I really like about it is that they enable scaling solutions such as layer 2. Various entities with various different technologies and stacks can define their own blockchains which have the finality and security of the underlying layer 1.

So there's a long list of reasons why we shouldn't add smart contracts to Monero. Short version is they're not private. They technically can be, that's what my talk is, but in general, they're not private. Everyone can see what's going on. They can be pretty slow. You're going from "Oh, I'm sending money to my friend", to "Oh, I'm executing this entire program. Please ensure that it has all of this database access and makes all of these calls successfully". They can also use a large storage. I believe Ethereum is up to two terabytes for their full nodes. And then one of the larger issues on the Monero side of things, if we were to try to add smart contracts, is we'd have to agree on one of the specifications, and there are several, all with their own reasons to do them and reasons not to do them. So it just adds a lot of hassle over debating over which specification is proper, and which one we should actually move forward with, and then trying to keep on that specification as the years progress.

So now that we kind of understand smart contracts, and why we should not add them to Monero, I want to establish another building block. This time, zk-SNARKs. zk-SNARKs are zero-knowledge proofs — they don't reveal anything inside of the proof. They just prove an overall relationship. And they're faster to verify than the program they execute, and they're smaller than the size of the program. And the fact that they're both faster and smaller gives you very interesting properties.

To throw some rough numbers at this, if anyone is actually experienced with this and hates my notation, you can strangle me, but please wait until after the talk. So a two to the 32 size program may take two to the 16 effort to verify. This would be if it was a square root complexity.

And because we can put these larger programs in smaller proofs, we can actually recurse these zk-SNARKs. We can put the 2** 32 program in a 2**16 proof, and then we can verify that as a program within a proof that only takes 2**8 of effort. So we can kind of shrink it down each and every time until we hit this minimum threshold, the smallest proof that can verify a one step larger proof. And that's kind of the recursion threshold and what this talk is premised upon.

So right now in Monero, we have outputs to one-time keys. We would change that. Output would actually be to one-time programs. So instead of saying: "This key can spend this output", we say: "This program decides if this output can be spent". And with that, again, we would not verify the one-time key signed the transaction. We would say: "Here is a zk-proof that there is some program". But we would not say which program is currently being executed. That would be inside the zero-knowledge proof, and we would say it is satisfied. And because the program which controls the output is satisfied, as proven within a zero-knowledge proof, which means no one else can see what the program was or what arguments it was passed to satisfy it — it would be completely indistinguishable. So all outputs would still look the same, despite having independent programmable logic determining if they're allowed to be spent.

This also gives us the very nice property of identical verification time and proof size. If you could say: "Oh, this program was twice slower", or "Sorry, this output to verify it's being spent properly, it took twice as long, you could see that it's a program that's twice as large". So we actually need them to have identical verification time and proof size. And that also means that the smart contracts aren't slow if it's a large smart contract. No matter if it's a very small program or a very large program, it's not Monero's problem, it's whoever has to deal with that problem. So it kind of achieves a denial of service resilience in that sense.

This idea isn't complete and I kind of want to take a step back to talk about that. If you consider the "Order Book" model of a decentralized exchange or any exchange in general, it's just Alice says: "Hey, I have 5 ABC. I want 10 XYZ. Who here can do that?" And Bob just sends 10 XYZ and claims the 5 ABC. This is just a very simple example of a decentralized exchange implemented with a smart contract. And once Bob does their part of the swap, Alice can claim the 10 XYZ they wanted. The main thing to note is that the state here is modeled completely in a consumable fashion. There's no global state and there's no reused variables.

If we instead go to automated market makers, which is a fancy term, which I don't want to get into, but I'll have to, this has been popularized by decentralized exchanges such as Uniswap. Instead of you making these limit orders and saying, I want this and I'll give that, you actually add liquidity. That liquidity is always available, can always serve as swaps. It is much faster to execute. It achieves all of these nice properties with regards to smart contracts.

And the way it specifically works is it defines a ratio of the current ABC amount and the current XYZ amount. And then when Bob wants to actually execute a swap, they just send him one ABC and they take out bit under the proportional amount, and that automatically shifts the price along a curve, bunch of math there. But basically, the state isn't "Oh, here's the list of orders we currently have", the state is simply the current balance of the smart contract.

And what's really great about this is whenever Bob wants to do a swap, they just have to go to the smart contract and send in some amount, and they'll get some amount out. They don't have to know about specific orders, and they don't have to expect that specific order to exist. If someone else did a swap on an order book, they might consume that order. But if someone else does a swap on this automated market maker, all it does is move the price point, and Bob's swap can still go through just at the different price point. So this is kind of this reusable global state.

Unfortunately, and this goes in a bit more detail on the slide behind me, consumable state is very easy to model, even though it's a lot more fragile and easy to get into conflicts with. But reusable state is the one you want for this really great user experience and what most modern smart contracts are ridden with. It's not that you can't write smart contracts to solely use consumable state, it's that modern smart contracts, in order to give the desired user experience, heavily rely on reusable state, because it allows multiple people to interact with a smart contract at once.

Unfortunately, this idea only achieves the first type. It only achieves consumable state. The reason for that is it can be done entirely with zk-proofs. If we wanted to use reusable state, we'd have to define validators and they'd have to be trusted to maintain privacy and we'd need fully homomorphic encryption. It's a whole thing. And to keep with Monero ethos, this idea solely does zk-proofs. It does technically define smart contracts, but with more limited UX than you might see with Ethereum. And that should be acknowledged.

With all of that in mind, I wanted to just briefly go over what privacy guarantees or claims this tries to achieve. The program itself would be private. You would not be able to tell which program is within an output, just as right now you can't tell which Monero address an output belongs to. You would not be able to tell the current state of the program. You would not be able to see: "Oh yeah, this is an order where Alice is trying to swap 5 ABC to 10 XYZ". No, that would be completely opaque. If we partner this with the full chain membership proofs technology, you would also not be able to tell what output is being spent. We could also technically go back to using ring signatures and then you couldn't tell which output is being spent within such a subset. But ideally we always move forward and never go back.

But all of this kind of raises the obvious question: "Hi, I'm a user. I want to use your smart contract. How do I know where it is or what's currently going on with it?" So if a user receives the program source code, or whatever the smart contract is, they could still verify it. It would be an effective program view key. So whoever is actually using a program would be able to see what it is and how it's currently doing. But any external observer or anyone not within that community would have no idea.

And then also the program itself can require that additional variables and changes be encrypted so anyone with this quote unquote program view key can decrypt the updates and track it over time, such as what's the state of this decentralized exchange at this current moment, what's the current price values, so on and so on.

And this is the really fun slide because it's where I get to make a lot of stuff up and have no accountability for it. I just had to claim everything this could possibly do in the future. We could enable P-256 ECDSA signatures instead of having "oh yeah, these fancy ring signatures" and with full chain membership proofs, generalized Schnorr protocols". No, now I get to claim that we could use very standard, widely adopted signatures. We would just verify those inside the zk- program and that would be completely private to the rest of the Monero blockchain. We could even do receipt of emails, because emails are actually signed authenticated infrastructure. There's actually work on Ethereum that's being done right now to use zk-proofs to verify emails were sent and control the flow of funds accordingly.

As I said at the start of the talk, my biggest interest from kind of this is we could get layer 2s without compromising Monero's ethos. Without just shoving this data and letting everyone see everything we could define outputs still completely private, still indistinguishable, still mixing with general user transactions. But despite that, they could be verifying full Ethereum virtual machine transitions and doing new smart contract platforms, more scalable privacy protocols, whatever.

We could also do like clients, so you could bridge Monero to Ethereum, bridge Ethereum back to Monero, so on and so on, with the only trust being on Monero's proof of work holding up. And the Ethereum validator is not equivocating, producing two different blockchains on their end.

So this is kind of the downside, where I have to say, well, I still shouldn't do this, even though it's kind of this really interesting idea. Despite every transaction taking the same amount of time and not having this denial of service factor where someone creates a really expensive program, it would still take a very long amount of time. Because now, instead of verifying that a transfer is valid, we're verifying that some program executed in zero knowledge, which is just a lot more work.

Practically, in order to service L2s — L2s would immediately make the Monero blockchain hit that 2 terabyte mark as well. So we would want to design this data publication network, where we do store data, but only for a limited amount of time. There's a whole bunch of commentary there. It's actually a really fascinating discussion on what's known as data availability. Ethereum did this with their blob storage. It's actually a design I quite appreciate.

And then, even if we were all in on this, you know, everyone here is like "Yes, let's do this", everyone here just becomes a Rust programmer overnight, and tomorrow we all pull out our laptops and just start hammering away on this. Yeah, it's still going to take us years, and then it's going to take a long time to review, audit, make sure it's secure, and justify deployment to the Monero mainnet. And honestly, a lot of our development time is currently going into node maintenance, new wallet software to finally replace wallet2, which has been the source of complaints for a while now. along with full chain membership proofs of my own work.

So while this is something I'd love to see in the future and is something that's going to become more and more feasible, and more and more desirable as the years go on, it's not quite there yet. The other one note against it I wanted to have is even if we did move forward on this today, and we had it ready within a few years, at that point, we may be wanting to deploy a post-quantum upgrade instead, because we need a post-quantum upgrade years before quantum computers, and we could be seeing quantum computers that can attack Monero within the next decade. So we may actually not have the time for multiple new protocol upgrades before that point, and that point is going to throw out most of the work we discuss here today anyways.

That's kind of it. I apologize if my flow was a bit off. I kind of noticed that. But if anyone has any questions…
